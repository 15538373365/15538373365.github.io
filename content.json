{"meta":{"title":"房鹏程的博客","subtitle":null,"description":"记录美好生活","author":"房鹏程","url":"http://fangpengcheng.com","root":"/"},"pages":[],"posts":[{"title":"Java的IO流","slug":"Java的IO流","date":"2020-07-30T05:55:07.000Z","updated":"2020-07-31T02:52:20.655Z","comments":true,"path":"2020/07/30/Java的IO流/","link":"","permalink":"http://fangpengcheng.com/2020/07/30/Java%E7%9A%84IO%E6%B5%81/","excerpt":"","text":"基本概念I/O就是Input/Output的简写，也就是输入/输出的含义。I/O流就是指像流水一样不间断地进行读写数据的状态。 基本分类 按照数据读写的单位不同分为：字节流 和 字符流。 其中字节流主要指以字节为单位进行读写的过程，可以读写任意类型的文件。 其中字符流主要指以字符(2个字节)为单位进行读写的过程，只能读写文本文件。 按照数据流动的方向不同分为：输入流 和 输出流(站在程序的角度)。 其中输入流主要指从文件中读取数据内容输入到程序中。 其中输出流主要指将程序中的数据内容输出到文件中，也就是写入文件。 基本框架 字节流的顶层父类：InputStream类 和 OutputStream类 - 抽象类 其中InputStream类的常用子类： FileInputStream类、DataInputStream类、ObjectInputStream类 其中OutputStream类的常用子类： FileOutputStream类、DataOutputStream类、ObjectOutputStream类 字符流的顶层父类：Reader类 和 Writer类 - 抽象类 其中Reader类的常用子类： BufferedReader类、InputStreamReader类 其中Writer类的常用子类： BufferedWriter类、OutputStreamWriter类补充： java.io.PrintStream类是OutputStream类的间接子类。 FileOutputStream类基本概念FileOutputStream类主要用于写入图像数据之类的原始字节流到输出流中 常用的方法 FileOutputStream(String name) - 根据参数指定的文件名来构造对象。 FileOutputStream(String name, boolean append) - 以追加的方式根据文件名构造对象。 void write(int b) - 用于将参数指定的单个字节写入输出流。 void write(byte[] b, int off, int len) - 用于将数组b中下标从off开始的len个字节写入输出流。 void write(byte[] b) - 用于将数组b中所有字节写入输出流。 void close() - 用于关闭流并释放有关的资源。 FileInputStream类基本概念 java.io.FileInputStream类主要用于从输入流中读取图像数据之类的字节流。 常用的方法 FileInputStream(String name) - 根据参数指定的文件名来构造对象。 int read() - 用于读取单个字节。 - 若读取到文件末尾则返回-1，否则返回实际读到的数据内容。 int read(byte[] b, int off, int len) - 用于从输入流中读取len个字节的数据放入数组b中下标从off开始的位置。 - 若读取到文件末尾则返回-1，否则返回实际读到的字节个数。 int read(byte[] b) - 用于从输入流中读取b.length个字节的数据放入数组b中。 int available() - 用于获取该输入流所关联文件的大小。 void close() DataOutputStream类基本概念 java.io.DataOutputStream类用于将Java基本数据类型的变量写入输出流中。 常用的方法 DataOutputStream(OutputStream out) - 根据参数指定的引用构造对象。 - 其中OutputStream类是个抽象类，实参需要传递子类的对象。 void writeInt(int v) - 用于将参数指定的整数以4字节的方式写入输出流中，先写入高字节。 - 127: 0000 0000 0000 0000 0000 0000 0111 1111 高 =&gt; 低 void close() DataInputStream类基本概念 java.io.DataInputStream类用于从输入流中读取Java基本数据类型的内容。 常用的方法 DataInputStream(InputStream in) - 根据参数指定的引用来构造对象。 - 其中InputStream类是个抽象类，实参需要传递子类的对象。 int readInt() - 用于读取4个字节的整数数据并返回。 void close() BufferedWriter类(重点)基本概念 java.io.BufferedWriter类用于写入单个字符、字符数组以及字符串到输出流中。 常用的方法 BufferedWriter(Writer out) - 根据参数指定的引用构造对象。 - 其中Writer类是个抽象类，因此实参需要传递子类的对象。 void write(int c) - 用于写入单个字符。 void write(char[] cbuf, int off, int len) - 用于将字符数组cbuf中下标从off开始的len个字符写入输出流。 void write(char[] cbuf) - 用于将字符数组cbuf中所有内容写入。 void write(String str) - 用于将参数指定的字符串内容写入输出流。 void newLine() - 用于写入行分隔符，不一定是\\n字符。 void close() BufferedReader类(重点)基本概念 java.io.BufferedReader类主要用于从输入流中读取单个字符、字符数组以及一行字符串。 常用的方法 BufferedReader(Reader in) - 根据参数指定的引用构造对象。 - 其中Reader类是个抽象类，实参需要传递子类的对象。 int read() - 用于从输入流中读取单个字符。 - 若读取到文件末尾则返回-1，否则返回实际读取到的数据内容对应的整数值。 int read(char[] cbuf, int off, int len) - 用于从输入流中读取len个字符放入数组cbuf中下标从off开始的位置。 - 若读取到文件末尾则返回-1，否则返回实际读取到的字符数。 int read(char[] cbuf) - 用于从输入流中读取cbuf.length个字符到数组cbuf中。 String readLine() - 用于从输入流中读取一行字符串内容。 - 若读取到文件末尾则返回null。 void close() PrintStream类(重点)基本概念 java.io.PrintStream类主要用于实现各种数据的打印并自动刷新。 常用的方法 PrintStream(OutputStream out) - 根据参数指定的引用构造对象。 - 其中OutputStream类是个抽象类，实参需要传递子类的对象。 void print(String s) - 用于打印参数指定的字符串内容。 void println(String x) - 用于打印参数字符串后终止该行。 void close()","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的File类","slug":"Java的File类","date":"2020-07-29T08:59:17.000Z","updated":"2020-07-29T09:40:04.544Z","comments":true,"path":"2020/07/29/Java的File类/","link":"","permalink":"http://fangpengcheng.com/2020/07/29/Java%E7%9A%84File%E7%B1%BB/","excerpt":"","text":"基本概念 java.io.File类主要用于描述文件和目录的路径信息，可以获取文件的大小等特征。 常用方法 File(String pathname) - 根据参数指定的路径名来构造对象。 boolean exists() - 用于判断文件或目录是否存在。 String getName() - 用于获取文件或目录的名称。 long length() - 用于获取文件的长度/大小。 long lastModified() - 用于获取最后一次修改时间。 - 返回最后一次修改时间距离1970年1月1日0时0分0秒的毫秒数 - 通常与Date类有参构造方法搭配使用。 String getAbsolutePath() - 用于获取绝对路径信息。 绝对路径：主要指以根目录开始的路径信息，如：c:/… d:/… /… 相对路径：主要指以当前工作目录开始的路径信息，如：./… . - 代表当前目录 .. - 代表当前目录的上一级目录。 在以后的开发中都采用相对路径信息。 boolean delete() - 用于删除文件或目录。 - 若删除的是目录，则要求该目录必须为空。 boolean createNewFile() - 用于创建新的空文件。 12345678910111213141516File f1 &#x3D; new File(&quot;d:&#x2F;a.txt&quot;);if(f1.exists()) &#123; System.out.println(&quot;文件目录名称：&quot;+f1.getName()); System.out.println(&quot;文件大小:&quot;+f1.length()); Date d1 &#x3D; new Date(f1.lastModified()); SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;最后一次修改时间&quot;+sdf.format(d1)); System.out.println(&quot;绝对路径:&quot;+f1.getAbsolutePath()); f1.delete();&#125;else &#123; try &#123; System.out.println(f1.createNewFile()?&quot;文件创建成功&quot;:&quot;文件创建失败&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; boolean mkdir() - 用于创建单层目录。 boolean mkdirs() - 用于创建多层目录。 12345678&#x2F;&#x2F;4.实现目录的创建和删除File f2 &#x3D; new File(&quot;c:&#x2F;捣乱&#x2F;猜猜我是谁&#x2F;就不告诉你&#x2F;死鬼&quot;);if(f2.exists())&#123; System.out.println(f2.delete()?&quot;删除目录成功&quot;:&quot;删除目录失败&quot;);&#125;else&#123; &#x2F;&#x2F;System.out.println(f2.mkdir()?&quot;创建目录成功&quot;:&quot;创建目录失败&quot;); System.out.println(f2.mkdirs()?&quot;创建目录成功&quot;:&quot;创建目录失败&quot;);&#125; File[] listFiles() - 用于获取当前目录中的所有内容。 boolean isFile() - 用于判断是否为一个标准文件。 boolean isDirectory() - 用于判断是否为一个目录。 12345678910111213&#x2F;&#x2F;5.实现目录中所有内容的获取并打印出来File f3 &#x3D; new File(&quot;D:\\\\java24\\\\day15&quot;);&#x2F;&#x2F;获取目录中的所有内容并返回File[] fArr &#x3D; f3.listFiles();&#x2F;&#x2F;遍历数组中的所有内容for(File tf : fArr)&#123; if(tf.isFile())&#123; System.out.println(tf.getName()); &#125; if(tf.isDirectory())&#123; System.out.println(&quot;[&quot; + tf.getName() + &quot;]&quot;); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的异常机制","slug":"Java的异常机制","date":"2020-07-28T08:02:47.000Z","updated":"2020-07-29T09:27:06.547Z","comments":true,"path":"2020/07/28/Java的异常机制/","link":"","permalink":"http://fangpengcheng.com/2020/07/28/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/","excerpt":"","text":"基本概念异常就是”不正常”的含义，在Java语言中主要指运行阶段发生的错误。java.lang.Throwable类是Java语言中错误(Error类) 和 异常(Exception类)的超类。其中Error类主要描述比较严重通常无法编码解决的错误，如：Java虚拟机挂了。其中Exception类主要描述轻微可以编码解决的错误，如：0作为除数。 异常的分类java.lang.Exception类是所有异常的超类，具体分类如下： RuntimeException异常 - 运行时异常，也叫做非检测性异常。 IOException和其它异常 - 其他异常，也叫做检测性异常。 - 所谓检测性异常就是在编译阶段能够被编译器检测出来并给出提示的异常。RuntimeException异常的主要子类： ArithmeticException - 算术异常 ArrayIndexOutOfBoundsException - 数组下标越界异常 NullPointerException - 空指针异常 ClassCastException - 类型转换异常 NumberFormatException - 数字格式异常 注意： 当程序执行过程中发生异常又没有手动处理时，则由Java虚拟机采用默认方式处理，而默认处理方式：打印异常的名称、异常的原因、异常发生位置后终止程序，导致后续代码无法执行 异常的避免对于绝大多数的非检测性异常可以直接使用if条件判断来避免该异常的发生。 123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F;故意发生一下算术异常int ia &#x3D; 10;int ib &#x3D; 0;if(ib !&#x3D; 0)&#123; System.out.println(ia &#x2F; ib);&#125;&#x2F;&#x2F;故意发生一下数组下标越界异常int[] arr &#x3D; new int[5];int pos &#x3D; 5;if(pos &gt;&#x3D; 0 &amp;&amp; pos &lt; 5)&#123; System.out.println(arr[pos]);&#125;&#x2F;&#x2F;故意发生一下空指针异常String str1 &#x3D; null;if(null !&#x3D; str1)&#123; System.out.println(str1.length());&#125;&#x2F;&#x2F;故意发生类型转换异常Exception ex &#x3D; new Exception();if(ex instanceof IOException)&#123; IOException ie &#x3D; (IOException)ex;&#125;&#x2F;&#x2F;故意发生数字格式异常String str2 &#x3D; &quot;123abc&quot;;if(str2.matches(&quot;\\\\d+&quot;))&#123; System.out.println(Integer.parseInt(str2));&#125;System.out.println(&quot;异常总算避免了！！！&quot;); 异常捕获(1)语法格式 try{ 编写所有可能发生异常的语句； } catch(异常类型 变量名){ 编写针对该类异常处理的语句； } … finally{ 编写无论是否发生异常都应该执行的语句； }(2)注意事项 a.若需要多个catch分支时，切记小类型的异常放在大类型的前面。 b.懒人的写法： catch(Exception e){ …} c.finally{}中的代码主要用于进行善后工作的处理，如：关闭打开的文件、删除文件等 异常抛出(1)基本概念 在某些特殊场合中无法处理或不便于处理发生的异常，此时就需要将异常转移给该方法的调用者处理，这种方式就叫异常的抛出。 (2)语法格式 访问控制符 返回值类型 方法名称(形参列表) throws 异常类型1,异常类型2,…{} 1234567public static void main(String[] args) throws IOException &#123; &#x2F;&#x2F;在以后的开发中不建议将main()方法中的异常抛出 FileInputStream fis &#x3D; new FileInputStream(&quot;c:&#x2F;a.txt&quot;); fis.close();&#125; (3)方法重写的原则 a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类。 b.要求方法权限不能变小，可以相同或变大。 c.要求不能抛出更大的异常。 1234public class TestExceptionA &#123; public void show() throws IOException&#123;&#125;&#125; 12345&#x2F;&#x2F;public void show() throws Exception&#123;&#125; 抛出更大的异常 error&#x2F;&#x2F;public void show() throws ApplicationException&#123;&#125; 抛出平级不一样的异常 error&#x2F;&#x2F;public void show() throws IOException&#123;&#125; 抛出一样的异常 ok&#x2F;&#x2F;public void show() throws FileNotFoundException&#123;&#125; 抛出更小的异常 okpublic void show()&#123;&#125; &#x2F;&#x2F;不抛出异常 ok 注意： 子类重写的方法可以抛出与父类一样的异常、更小的异常以及不抛出异常，但不能抛出更大的异常或平级不一样的异常。 自定义异常(1)基本概念 虽然Java官方提供了大量异常类但没有专门针对年龄不合理的异常类，若希望使用这种针对性的异常就需要程序员自己写一个异常类。 (2)实现流程 a.自定义XXXException继承Exception或者其子类； b.提供两个版本的构造方法：无参构造 和 字符串作为参数的构造； (3)异常对象的产生 throw new 异常类型();如： throw new NullPointerException(); - 表示产生空指针异常 123456789101112131415161718192021222324&#x2F;*** * 年龄异常类 * @author 26385 * *&#x2F;public class AgeException extends Exception&#123; &#x2F;** * *&#x2F; private static final long serialVersionUID &#x3D; 1L; public AgeException() &#123;&#125; public AgeException(String msg) &#123; super(msg);&#x2F;&#x2F;子类中指代父类对象 &#x2F;** * super的三种使用情况： 访问父类的方法。 调用父类构造方法。 访问父类中的隐藏成员变量。 *&#x2F; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Person &#123; private String name; private int age; public Person() &#123; super(); &#x2F;&#x2F; TODO Auto-generated constructor stub &#125; public Person(String name, int age) throws AgeException &#123; super(); setName(name); setAge(age); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) throws AgeException &#123; if(age&gt;0 &amp;&amp; age&lt;150) &#123; this.age &#x3D; age; &#125;else &#123; throw new AgeException(&quot;年龄不符合!&quot;); &#125; &#125; @Override public int hashCode() &#123; final int prime &#x3D; 31; int result &#x3D; 1; result &#x3D; prime * result + age; result &#x3D; prime * result + ((name &#x3D;&#x3D; null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this &#x3D;&#x3D; obj) return true; if (obj &#x3D;&#x3D; null) return false; if (getClass() !&#x3D; obj.getClass()) return false; Person other &#x3D; (Person) obj; if (age !&#x3D; other.age) return false; if (name &#x3D;&#x3D; null) &#123; if (other.name !&#x3D; null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; @Override public String toString() &#123; return &quot;Person [name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;]&quot;; &#125;&#125; 测试类: 1234567891011public class TestAgeException &#123; public static void main(String[] args) &#123; Person p &#x3D; null; try &#123; p&#x3D;new Person(&quot;zhangfei&quot;,-30); &#125; catch (AgeException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;p &#x3D; &quot; + p); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的Map接口","slug":"Java的Map接口","date":"2020-07-28T06:55:03.000Z","updated":"2020-07-28T07:48:41.687Z","comments":true,"path":"2020/07/28/Java的Map接口/","link":"","permalink":"http://fangpengcheng.com/2020/07/28/Java%E7%9A%84Map%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"基本概念 java.util.Map&lt;K,V&gt;接口中存放元素的基本单位是：单对元素。 K - 用于描述键(Key)的类型。 V - 用于描述值(Value)的类型。 该接口的主要实现类：HashMap类 和 TreeMap类。 该接口中key(键)不允许重复，而且每个key(键)只能对应一个Value(值)。 HashMap和Hashset的关系Hashset是基于HashMap实现的 常用的方法V put(K key, V value) - 用于将key和value组成一对放入当前集合中。 - 若实现增加功能则返回null；若实现修改功能则返回原来的value. 1234567891011&#x2F;&#x2F;1.声明Map类型的引用指向实现类的对象Map&lt;Integer, String&gt; m1 &#x3D; new HashMap&lt;Integer, String&gt;();&#x2F;&#x2F;2.向集合中添加元素String str1 &#x3D; m1.put(1, &quot;one&quot;);System.out.println(&quot;str1 &#x3D; &quot; + str1); &#x2F;&#x2F;nullSystem.out.println(&quot;m1 &#x3D; &quot; + m1);&#x2F;&#x2F;&#123;1&#x3D;one&#125;&#x2F;&#x2F;3.修改str1 &#x3D; m1.put(1, &quot;eleven&quot;);System.out.println(&quot;str1 &#x3D; &quot; + str1); &#x2F;&#x2F;oneSystem.out.println(&quot;m1 &#x3D; &quot; + m1); &#x2F;&#x2F;&#123;1&#x3D;eleven&#125; boolean containsKey(Object key) - 用于判断当前集合中是否存在参数指定的key。 12345&#x2F;&#x2F;3.查找Map集合中是否拥有指定的key以及指定的value并打印boolean b1 &#x3D; m1.containsKey(&quot;4&quot;);System.out.println(&quot;b1 &#x3D; &quot; + b1); &#x2F;&#x2F;falseb1 &#x3D; m1.containsKey(&quot;1&quot;);System.out.println(&quot;b1 &#x3D; &quot; + b1); &#x2F;&#x2F;true boolean containsValue(Object value) - 用于判断当前集合中是否存在参数指定的value。 1234b1 &#x3D; m1.containsValue(&quot;eleven&quot;);System.out.println(&quot;b1 &#x3D; &quot; + b1); &#x2F;&#x2F;falseb1 &#x3D; m1.containsValue(&quot;three&quot;);System.out.println(&quot;b1 &#x3D; &quot; + b1); &#x2F;&#x2F;true V get(Object key) - 用于根据参数指定的key返回对应的value，若key不存在则返回null。 12345&#x2F;&#x2F;4.根据参数指定的key返回对应的value，若不存在则返回nullString str1 &#x3D; m1.get(&quot;5&quot;);System.out.println(&quot;str1 &#x3D; &quot; + str1); &#x2F;&#x2F;nullstr1 &#x3D; m1.get(&quot;2&quot;);System.out.println(&quot;str1 &#x3D; &quot; + str1); &#x2F;&#x2F;two V remove(Object key) - 用于根据参数指定的key来删除键值对，返回该key对应的value。 123String str2 &#x3D; m1.remove(&quot;10&quot;);System.out.println(&quot;str2 &#x3D; &quot; + str2); &#x2F;&#x2F;nullSystem.out.println(&quot;m1 &#x3D; &quot; + m1); &#x2F;&#x2F;&#123;1&#x3D;one, 2&#x3D;two, 3&#x3D;three&#125; Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() - 用于将Map集合转换为Set集合，集合中的每个元素都是键值对。 - 其中Map.Entry是接口类型，常用方法有： K getKey() - 用于获取键值对中的键。 V getValue() - 用于获取键值对中的值。 123456&#x2F;&#x2F;实现Map集合向Set集合的转换Set&lt;Entry&lt;String, String&gt;&gt; s1 &#x3D; m1.entrySet();&#x2F;&#x2F;使用for each结构来打印Set集合中的所有元素for (Entry&lt;String, String&gt; e1 : s1) &#123; System.out.println(e1.getKey()+&quot;&#x3D;&quot;+e1.getValue());&#125; Set keySet() - 用于将Map集合中的所有键放入Set集合中并返回。 123456&#x2F;&#x2F;实现Map集合中所有的key转换为Set集合Set&lt;String&gt; k1 &#x3D; m1.keySet();&#x2F;&#x2F;使用for each结构打印Set集合中的所有元素for (String s2 : k1) &#123; System.out.println(s2+&quot;&#x3D;&quot;+m1.get(s2));&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"OA的实用sql语句","slug":"OA的实用sql语句","date":"2020-07-28T06:00:01.000Z","updated":"2020-07-28T06:02:15.978Z","comments":true,"path":"2020/07/28/OA的实用sql语句/","link":"","permalink":"http://fangpengcheng.com/2020/07/28/OA%E7%9A%84%E5%AE%9E%E7%94%A8sql%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"cap4应用发布状态更改未发布状态12&#x2F;&#x2F;其中发布状态 0:未发布 1:已发布update CAP_BIZ_CONFIG set publish_flag&#x3D;0 where id&#x3D;-7437066624847231468","categories":[],"tags":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"}]},{"title":"Java的TreeSet集合","slug":"Java的TreeSet集合","date":"2020-07-28T01:56:50.000Z","updated":"2020-07-28T05:54:20.272Z","comments":true,"path":"2020/07/28/Java的TreeSet集合/","link":"","permalink":"http://fangpengcheng.com/2020/07/28/Java%E7%9A%84TreeSet%E9%9B%86%E5%90%88/","excerpt":"","text":"二叉树?二叉树就是指每个节点最多只有两个子节点的树形结构。 有序二叉树?满足以下3个条件的二叉树就叫做有序二叉树，具体如下： a.要求左子树中任意节点都小于根节点； b.要求右子树中任意节点都大于根节点； c.要求左子树和右子树的内部也要遵守上述要求； TreeSet集合的原理由于TreeSet集合的底层是采用有序二叉树实现的，当插入新元素到TreeSet集合时需要比较新元素与已有元素的大小来确定新元素的位置，从而保证二叉树依然有序，而比较方式有两种 a.使用元素的自然排序规则比较，也就是让元素类型实现java.lang.Comparable接口； b.使用比较器规则比较，也就是创建TreeSet集合时传入java.util.Comparator接口； 自然排序规则比较1234567891011Set&lt;Student&gt; s2 &#x3D; new TreeSet&lt;Student&gt;();&#x2F;&#x2F; 添加元素s2.add(new Student(1003, &quot;zhaoyun&quot;, 25));s2.add(new Student(1001, &quot;zhangfei&quot;, 30));s2.add(new Student(1005, &quot;machao&quot;, 18));s2.add(new Student(1002, &quot;guanyu&quot;, 35));s2.add(new Student(1004, &quot;huangzhong&quot;, 40));&#x2F;&#x2F; 使用增强版的for循环打印所有元素for (Student ts : s2) &#123; System.out.println(ts);&#125; Student需要继承Comparable接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Student implements Comparable&lt;Student&gt;&#123; private int id; private String name; private int age; public Student() &#123; super(); &#125; public Student(int id, String name, int age) &#123; super(); setId(id); setName(name); setAge(age); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; if(id &gt; 0)&#123; this.id &#x3D; id; &#125;else&#123; System.out.println(&quot;学号不合理！！！&quot;); &#125; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age &gt;&#x3D; 4 &amp;&amp; age &lt;&#x3D; 60)&#123; this.age &#x3D; age; &#125;else&#123; System.out.println(&quot;年龄不合理！！！&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Student [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;]&quot;; &#125; @Override public int hashCode() &#123; final int prime &#x3D; 31; int result &#x3D; 1; result &#x3D; prime * result + id; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this &#x3D;&#x3D; obj) return true; if (obj &#x3D;&#x3D; null) return false; if (getClass() !&#x3D; obj.getClass()) return false; Student other &#x3D; (Student) obj; if (id !&#x3D; other.id) return false; return true; &#125; @Override public int compareTo(Student o) &#123; &#x2F;&#x2F;表示调用对象和参数对象相等，其中调用对象指新增加的元素，参数对象指已有元素 &#x2F;&#x2F;return 0; &#x2F;&#x2F;表示调用对象大于参数对象，也就是新增加的元素大 &#x2F;&#x2F;return 1; &#x2F;&#x2F;表示调用对象小于参数对象，也就是新增加的元素小 &#x2F;&#x2F;return -1; &#x2F;&#x2F;表示按照学号进行排序 &#x2F;&#x2F;return this.getId() - o.getId(); &#x2F;&#x2F;表示按照姓名进行排序 &#x2F;&#x2F;return this.getName().compareTo(o.getName()); &#x2F;&#x2F;表示按照年龄进行排序 &#x2F;&#x2F;return this.getAge() - o.getAge(); &#x2F;&#x2F;表示先按照学号排序，若学号相同则按照姓名排序 int num &#x3D; this.getId() - o.getId(); return num !&#x3D; 0? num: this.getName().compareTo(o.getName()); &#125; 结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x2F;&#x2F;return 0; Student [id&#x3D;1003, name&#x3D;zhaoyun, age&#x3D;25]&#x2F;&#x2F;return 1;Student [id&#x3D;1003, name&#x3D;zhaoyun, age&#x3D;25]Student [id&#x3D;1001, name&#x3D;zhangfei, age&#x3D;30]Student [id&#x3D;1005, name&#x3D;machao, age&#x3D;18]Student [id&#x3D;1002, name&#x3D;guanyu, age&#x3D;35]Student [id&#x3D;1004, name&#x3D;huangzhong, age&#x3D;40]&#x2F;&#x2F;return -1;Student [id&#x3D;1004, name&#x3D;huangzhong, age&#x3D;40]Student [id&#x3D;1002, name&#x3D;guanyu, age&#x3D;35]Student [id&#x3D;1005, name&#x3D;machao, age&#x3D;18]Student [id&#x3D;1001, name&#x3D;zhangfei, age&#x3D;30]Student [id&#x3D;1003, name&#x3D;zhaoyun, age&#x3D;25]&#x2F;&#x2F;return this.getId() - o.getId();Student [id&#x3D;1001, name&#x3D;zhangfei, age&#x3D;30]Student [id&#x3D;1002, name&#x3D;guanyu, age&#x3D;35]Student [id&#x3D;1003, name&#x3D;zhaoyun, age&#x3D;25]Student [id&#x3D;1004, name&#x3D;huangzhong, age&#x3D;40]Student [id&#x3D;1005, name&#x3D;machao, age&#x3D;18]&#x2F;&#x2F;return this.getName().compareTo(o.getName());Student [id&#x3D;1002, name&#x3D;guanyu, age&#x3D;35]Student [id&#x3D;1004, name&#x3D;huangzhong, age&#x3D;40]Student [id&#x3D;1005, name&#x3D;machao, age&#x3D;18]Student [id&#x3D;1001, name&#x3D;zhangfei, age&#x3D;30]Student [id&#x3D;1003, name&#x3D;zhaoyun, age&#x3D;25]&#x2F;&#x2F;return this.getAge() - o.getAge();Student [id&#x3D;1005, name&#x3D;machao, age&#x3D;18]Student [id&#x3D;1003, name&#x3D;zhaoyun, age&#x3D;25]Student [id&#x3D;1001, name&#x3D;zhangfei, age&#x3D;30]Student [id&#x3D;1002, name&#x3D;guanyu, age&#x3D;35]Student [id&#x3D;1004, name&#x3D;huangzhong, age&#x3D;40]&#x2F;&#x2F;int num &#x3D; this.getId() - o.getId();&#x2F;&#x2F;return num !&#x3D; 0? num: this.getName().compareTo(o.getName());Student [id&#x3D;1001, name&#x3D;zhangfei, age&#x3D;30]Student [id&#x3D;1002, name&#x3D;guanyu, age&#x3D;35]Student [id&#x3D;1003, name&#x3D;zhaoyun, age&#x3D;25]Student [id&#x3D;1004, name&#x3D;huangzhong, age&#x3D;40]Student [id&#x3D;1005, name&#x3D;machao, age&#x3D;18] 使用比较器来指定比较的规则12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F;使用比较器来指定比较的规则&#x2F;&#x2F; 接口&#x2F;父类类型 引用变量名 &#x3D; new 接口&#x2F;父类类型()&#123; 方法的重写 &#125;;Comparator&lt;Student&gt; c1 &#x3D; new Comparator&lt;Student&gt;() &#123; &#x2F;&#x2F; o1代表新增加的元素, o2代表集合中已有的元素 @Override public int compare(Student o1, Student o2) &#123; &#x2F;&#x2F; 按照学号大小进行排序 return o1.getId() - o2.getId(); &#125;&#125;;Comparator&lt;Student&gt; c2 &#x3D; new Comparator&lt;Student&gt;() &#123; &#x2F;&#x2F; o1代表新增加的元素, o2代表集合中已有的元素 @Override public int compare(Student o1, Student o2) &#123; &#x2F;&#x2F; 按照姓名大小进行排序 return o1.getName().compareTo(o2.getName()); &#125;&#125;;Comparator&lt;Student&gt; c3 &#x3D; new Comparator&lt;Student&gt;() &#123; &#x2F;&#x2F; o1代表新增加的元素, o2代表集合中已有的元素 @Override public int compare(Student o1, Student o2) &#123; &#x2F;&#x2F; 按照年龄大小进行排序 return o1.getAge() - o2.getAge(); &#125;&#125;;&#x2F;&#x2F; 表示该集合按照c1指定的规则来比较元素的大小Set&lt;Student&gt; s3 &#x3D; new TreeSet&lt;Student&gt;(c3);&#x2F;&#x2F; 添加元素s3.add(new Student(1003, &quot;zhaoyun&quot;, 25));s3.add(new Student(1001, &quot;zhangfei&quot;, 30));s3.add(new Student(1005, &quot;machao&quot;, 18));s3.add(new Student(1002, &quot;guanyu&quot;, 35));s3.add(new Student(1004, &quot;huangzhong&quot;, 40));&#x2F;&#x2F; 使用增强版的for循环打印所有元素for (Student ts : s3) &#123; System.out.println(ts);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"java的HashSet集合","slug":"java的HashSet集合","date":"2020-07-27T08:45:21.000Z","updated":"2020-07-27T08:54:19.119Z","comments":true,"path":"2020/07/27/java的HashSet集合/","link":"","permalink":"http://fangpengcheng.com/2020/07/27/java%E7%9A%84HashSet%E9%9B%86%E5%90%88/","excerpt":"","text":"HashSet的基本概念元素放入HashSet集合的原理(理解)(1)使用新元素调用hashCode()方法得到该元素的哈希码值；(2)将哈希码值交给哈希算法算出新元素在哈希表数组的索引位置；(3)若该位置没有元素，则直接将新元素放入即可；(4)若该位置有元素，则使用新元素与已有元素依次比较；(5)若新元素与已有元素相等，则放弃新元素的插入保留旧元素；(6)若新元素与已有元素都不相等，则将新元素放入所有已有元素的后面； 为啥要保持equals()方法和hashCode()方法的一致性呢？为了确保相同数值的内容调用equals()方法的结果相等，此时各自调用hashCode()方法的结果相同，此时交由同样的哈希算法算出的索引位置相同，减少比较的次数从而提高性能。 常用方法 Iterator iterator() 返回在此 set 中的元素上进行迭代的迭代器。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的Set接口","slug":"Java的Set接口","date":"2020-07-23T09:53:29.000Z","updated":"2020-07-28T01:45:32.921Z","comments":true,"path":"2020/07/23/Java的Set接口/","link":"","permalink":"http://fangpengcheng.com/2020/07/23/Java%E7%9A%84Set%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"Set接口基本概念java.util.Set接口是Collection接口的子接口，与List接口是平级关系。该接口与List接口相比元素没有先后次序，并且不允许有重复的元素。该接口的主要实现类：HashSet类 和 TreeSet类。其中HashSet类的底层是采用哈希表进行数据管理的。 其中TreeSet类的底层是采用有序二叉树进行数据管理的。 二叉树: 有序二叉树: 常用方法以下方法练习可以参考“List集合” boolean add(E e)确保此 collection 包含指定的元素（可选操作）。 boolean addAll(Collection&lt;? extends E&gt; c)将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。 void clear()移除此 collection 中的所有元素（可选操作）。 boolean contains(Object o)如果此 collection 包含指定的元素，则返回 true。 boolean containsAll(Collection&lt;?&gt; c)如果此 collection 包含指定 collection 中的所有元素，则返回 true。 boolean equals(Object o)比较此 collection 与指定对象是否相等。 int hashCode()返回此 collection 的哈希码值。 boolean isEmpty()如果此 collection 不包含元素，则返回 true。 Iterator iterator()返回在此 collection 的元素上进行迭代的迭代器。12345678910111213141516171819202122&#x2F;&#x2F; 3.使用迭代器来访问集合中的每个元素并打印出来Iterator&lt;String&gt; it1 &#x3D; s1.iterator();while(it1.hasNext())&#123; System.out.println(&quot;获取到的元素是：&quot; + it1.next()); &#x2F;&#x2F;one two three&#125;&#x2F;&#x2F;4.使用迭代器实现toStringStringBuffer sb &#x3D; new StringBuffer();sb.append(&quot;[&quot;);Iterator&lt;String&gt; it2 &#x3D; s1.iterator();while(it2.hasNext()) &#123; String str &#x3D; it2.next();&#x2F;&#x2F;取出当前元素，指针移动到下一个元素 if(it2.hasNext()) &#123; sb.append(str).append(&quot;,&quot;).append(&quot; &quot;); &#125;else&#123; sb.append(str).append(&quot;]&quot;); &#125;&#125;System.out.println(sb);&#x2F;&#x2F;[one, two, three]注意：当使用迭代器访问元素时不允许调用集合的方法删除元素（remove），否则会发生ConcurrentModificationException并发修改异常。 boolean hasNext()如果仍有元素可以迭代，则返回 true。 E next()返回迭代的下一个元素。 void remove()从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。 boolean remove(Object o)从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。 boolean removeAll(Collection&lt;?&gt; c)移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。 boolean retainAll(Collection&lt;?&gt; c)仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。 int size()返回此 collection 中的元素数。 Object[] toArray()返回包含此 collection 中所有元素的数组。 T[] toArray(T[] a) 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的Queue接口","slug":"Java的Queue接口","date":"2020-07-23T04:02:18.000Z","updated":"2020-07-23T09:50:05.178Z","comments":true,"path":"2020/07/23/Java的Queue接口/","link":"","permalink":"http://fangpengcheng.com/2020/07/23/Java%E7%9A%84Queue%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"Queue接口java.util.Queue接口是Collection接口的子接口，与List接口是平级关系。该接口主要用于描述具有先进先出特性的数据结构，叫做队列(FIFO first in first out)该接口的主要实现类是：LinkedList，该类在增删方面有一定的优势。 常用方法12&#x2F;&#x2F;1.声明Queue接口类型的引用指向实现类的对象Queue&lt;Integer&gt; q1 &#x3D; new LinkedList&lt;Integer&gt;(); boolean offer(E e) - 用于将参数指定的元素e插入当前队列。 12345&#x2F;&#x2F;2.将元素11 22 33 44 55依次进行入队操作并打印for (int i &#x3D; 1; i &lt;&#x3D;5; i++) &#123; q1.offer(new Integer(i*11));&#125;System.out.println(q1);&#x2F;&#x2F;[11, 22, 33, 44, 55] E poll() - 用于获取并移除队列的队首元素，若队列为空则返回null。 12&#x2F;&#x2F;3.查看队列中队首元素值并打印System.out.println(q1.peek());&#x2F;&#x2F;11 E peek() - 用于获取队列的队首元素，若队列为空则返回null。 12345678 &#x2F;&#x2F;4.将队列中的所有元素依次进行出队操作并打印 int size &#x3D; q1.size(); System.out.println(size); for (int i &#x3D; 1; i &lt;&#x3D;size; i++) &#123; System.out.println(q1.poll()); &#125; &#x2F;&#x2F;5.查看出队之后的结果System.out.println(q1);&#x2F;&#x2F;[]","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java中的泛型","slug":"Java中的泛型","date":"2020-07-22T09:51:16.000Z","updated":"2020-07-23T03:08:37.894Z","comments":true,"path":"2020/07/22/Java中的泛型/","link":"","permalink":"http://fangpengcheng.com/2020/07/22/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"泛型是概念通常情况下集合中允许存放各种不同类型的对象，此时这些对象都被看做Object类型放入，当集合中的这些数据被取出之后也是Object类型，为了表达数据的真实类型需要做强制类型转换，而强制类型转换很可能引发类型转换异常。 为了避免上述问题的发生，从jdk1.5开始提出泛型机制，要求在集合名称的右边使用&lt;数据类型&gt;的方式明确要求该集合可以存放的元素类型，若放入其他类型数据则编译报错。如： List lt1 = new LinkedList(); - 元素类型只能是String类型 泛型的本质就是参数化类型，也就是让数据类型作为参数传递的方式，其中E相当于形式参数负责占位，当准备集合时&lt;&gt;中的数据类型相当于实际参数负责给形式参数E进行赋值，此时集合中所有E都被替换为实际参数类型，由于实际参数可以传递的类型非常广泛，因此得名&quot;泛型&quot;12345678910111213141516171819&#x2F;&#x2F;1.使用泛型机制准备一个集合List&lt;String&gt; lt1 &#x3D; new LinkedList&lt;String&gt;();&#x2F;&#x2F;向集合中添加元素lt1.add(&quot;one&quot;);&#x2F;&#x2F;lt1.add(2); errorSystem.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[one]System.out.println(&quot;----------------------------------&quot;);&#x2F;&#x2F;2.从集合中取出元素String str1 &#x3D; lt1.get(0);System.out.println(&quot;获取到的元素是：&quot; + str1);System.out.println(&quot;----------------------------------&quot;);&#x2F;&#x2F;集合中元素的类型是IntegerList&lt;Integer&gt; lt2 &#x3D; new LinkedList&lt;Integer&gt;();&#x2F;&#x2F;元素类型为StudentList&lt;Student&gt; lt3 &#x3D; new LinkedList&lt;Student&gt;();&#x2F;&#x2F;从jdk1.7开始增加新特性：后面&lt;&gt;中的数据类型可以省略 叫做菱形特性List&lt;Student&gt; lt4 &#x3D; new LinkedList&lt;&gt;();","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的List集合","slug":"Java的List集合","date":"2020-07-22T02:31:04.000Z","updated":"2020-07-22T09:27:54.360Z","comments":true,"path":"2020/07/22/Java的List集合/","link":"","permalink":"http://fangpengcheng.com/2020/07/22/Java%E7%9A%84List%E9%9B%86%E5%90%88/","excerpt":"","text":"List基本概念java.util.List接口是Collection接口的子接口该集合中的所有元素拥有先后放入次序，并且允许重复该集合的主要实现类由：ArrayList类、LinkedList类、Stack类以及Vector类（过时） 其中ArrayList类的底层是采用动态数组实现的，因此访问元素方便，增删元素不方便。其中LinkedList类的底层是采用链表实现的，因此访问元素不方便，增删元素方便。 其中Stack类的底层是采用动态数组实现的，该集合主要用于描述具有后进先出特性的数据结构，叫做栈(last in first out LIFO)。 其中Vector类的底层采用动态数组实现的，该集合与ArrayList类相比属于早期线程安全的类，效率比较低，因此推荐使用ArrayList类。 常用方法12&#x2F;&#x2F;1.声明List类型的引用指向实现类的对象，形成多态List lt1 &#x3D; new LinkedList(); void add(int index, E element) - 用于将元素element插入到下标index的位置。 123456789101112&#x2F;&#x2F;2.向集合中添加元素并打印出来lt1.add(&quot;one&quot;);System.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[one]&#x2F;&#x2F;实现向开头位置插入元素：向下标为0的位置插入元素1lt1.add(0, 1);System.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[1, one]&#x2F;&#x2F;实现向中间位置插入元素lt1.add(1, &quot;two&quot;);System.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[1, two, one]&#x2F;&#x2F;实现向末尾位置插入元素lt1.add(lt1.size(), 2);System.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[1, two, one, 2] boolean addAll(int index, Collection&lt;? extends E&gt; c) - 用于将集合c中的所有元素插入到下标index的位置。 123456789&#x2F;&#x2F;3.准备另外一个集合，将集合中的所有元素放入集合lt1中List lt2 &#x3D; new LinkedList();lt2.add(3);lt2.add(&quot;three&quot;);System.out.println(&quot;lt2 &#x3D; &quot; + lt2); &#x2F;&#x2F;[3, three]&#x2F;&#x2F;向下标为2的位置插入集合lt2中的所有元素lt1.addAll(2, lt2);&#x2F;&#x2F;自动调用toString()方法打印结果 String类型的整体System.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[1, two, 3, three, one, 2] E get(int index) - 用于根据参数index指定的下标获取对应的元素并返回。 1234567891011121314151617181920212223242526272829&#x2F;&#x2F;思考：为啥get方法的返回值类型是Object类型呢？&#x2F;&#x2F;解析：集合中之所以允许存放各种不同类型的对象，是因为将所有对象都看做&#x2F;&#x2F; Object类型放入的，那么取出来的元素类型也必然是Object类型&#x2F;&#x2F;获取下标为0的元素内容并打印出来&#x2F;&#x2F;为了表达该元素最真实的数据类型，就需要强制类型转换Integer it1 &#x3D; (Integer) lt1.get(0);System.out.println(&quot;it1 &#x3D; &quot; + it1); &#x2F;&#x2F;it1 &#x3D; 1&#x2F;&#x2F;获取下标为1的元素内容并打印出来String str1 &#x3D; (String)lt1.get(1);System.out.println(&quot;str1 &#x3D; &quot; + str1); &#x2F;&#x2F;str1 &#x3D; twoSystem.out.println(&quot;--------------------------------------&quot;);&#x2F;&#x2F;若希望将集合中的所有元素获取出来并直接打印for(int i &#x3D; 0; i &lt; lt1.size(); i++)&#123; &#x2F;&#x2F;使用get()方法可以将集合中的元素一个个取出来，比toString()更加灵活 System.out.println(&quot;下标&quot; + i + &quot;位置获取到的元素是：&quot; + lt1.get(i));&#125;System.out.println(&quot;--------------------------------------&quot;);&#x2F;&#x2F;练习：使用StringBuilder类实现get方法获取所有元素的结果与toString相同&#x2F;&#x2F;lt1 &#x3D; [1, two, 3, three, one, 2]StringBuilder sb &#x3D; new StringBuilder();sb.append(&quot;[&quot;);for (int i &#x3D; 0; i &lt; lt1.size(); i++) &#123; sb.append(lt1.get(i)).append(&quot;,&quot;).append(&quot; &quot;);&#x2F;&#x2F;连续调用append&#125;&#x2F;&#x2F;最后一个元素的后面没有逗号加空格，而是]sb.delete(sb.length()-2, sb.length()).append(&quot;]&quot;);System.out.println(sb);System.out.println(&quot;--------------------------------------&quot;); E remove(int index) - 用于根据参数index指定的下标位置来删除元素。 - 返回被删除的元素值。 123456789101112131415161718192021&#x2F;&#x2F;5.根据下标来删除指定的元素System.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[1, two, 3, three, one, 2]&#x2F;&#x2F;删除下标为0的元素并打印出来Integer it2 &#x3D; (Integer) lt1.remove(0);System.out.println(&quot;被删除的元素是：&quot; + it2); &#x2F;&#x2F;1System.out.println(&quot;删除之后集合的元素有：&quot; + lt1); &#x2F;&#x2F;[two, 3, three, one, 2]&#x2F;&#x2F;删除下标为3的元素并打印出来String str2 &#x3D; (String) lt1.remove(3);System.out.println(&quot;被删除的元素是：&quot; + str2); &#x2F;&#x2F;oneSystem.out.println(&quot;删除之后集合的元素有：&quot; + lt1);&#x2F;&#x2F;[two, 3, three, 2]System.out.println(&quot;--------------------------------------&quot;);&#x2F;&#x2F;实现将所有元素删除 4 3 2for(int i &#x3D; 0; i &lt; lt1.size(); &#x2F;*i++*&#x2F;)&#123; System.out.println(&quot;被删除的元素是：&quot; + lt1.remove(i));&#125;for(int i &#x3D; lt1.size()-1; i &gt;&#x3D; 0; i--)&#123; System.out.println(&quot;被删除的元素是：&quot; + lt1.remove(i));&#125;System.out.println(&quot;删除之后集合的元素有：&quot; + lt1); &#x2F;&#x2F;啥也没有 E set(int index, E element) - 用于将参数index指定下标位置的元素修改为element，返回修改之前的元素。 12345678910111213&#x2F;&#x2F; 6.实现元素的修改&#x2F;替换功能 System.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[1, two, 3, three, one, 2] &#x2F;&#x2F;实现将集合中元素3修改为&quot;three&quot; Integer it3 &#x3D; (Integer) lt1.set(2, &quot;three&quot;); System.out.println(&quot;被替换的元素是：&quot; + it3); &#x2F;&#x2F;3 System.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[1, two, three, three, one, 2] &#x2F;&#x2F;实现将集合中元素2修改为&quot;two&quot; Integer it4 &#x3D; (Integer)lt1.set(5, &quot;two&quot;);&#x2F;&#x2F;[1, two, three, three, one, two] &#x2F;&#x2F;每次调用方法时需要严格核对被替换元素的数据类型，否则很容易发生异常 &#x2F;&#x2F;对代码的编写带来很多的困难 &#x2F;&#x2F;String str3 &#x3D; (String)lt1.set(3, &quot;two&quot;); &#x2F;&#x2F;发生类型转换异常 System.out.println(&quot;被替换的元素是：&quot; + it4); &#x2F;&#x2F;2 System.out.println(&quot;lt1 &#x3D; &quot; + lt1); &#x2F;&#x2F;[1, two, three, three, one, two]","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"OA超级节点","slug":"OA超级节点","date":"2020-07-21T09:32:59.000Z","updated":"2020-07-21T10:41:11.870Z","comments":true,"path":"2020/07/21/OA超级节点/","link":"","permalink":"http://fangpengcheng.com/2020/07/21/OA%E8%B6%85%E7%BA%A7%E8%8A%82%E7%82%B9/","excerpt":"","text":"超级节点的简介当我们在OA审批中需要去第三方系统审批，那么就可以使用超级节点传递数据给第三方，让第三方来决定数据的正确与否，对流程进行通过、暂存待办、回退、转干预人 超级节点示例继承BaseSuperNodeAction类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class yqzlNodeFpc extends BaseSuperNodeAction &#123; @Override public void cancelAction(String token, String returnTime, Map&lt;String, Object&gt; params) &#123; log.info(&quot;cancelAction-撤销&quot;); &#125; @Override public SuperNodeResponse confirmAction(String token, String returnTime, Map&lt;String, Object&gt; params) &#123; return executeAction(token,returnTime,params); &#125; @Override public SuperNodeResponse executeAction(String token, String returnTime, Map&lt;String, Object&gt; params) &#123; SuperNodeResponse response &#x3D; new SuperNodeResponse(); Map&lt;String, Object&gt; data &#x3D; getFormData(params); Map&lt;String, Object&gt; map &#x3D; nscDataProcessingManager.dataProcessing(token,data); if(&quot;0&quot;.equals(NscUtils.getString(map.get(&quot;result&quot;)))) &#123;&#x2F;&#x2F;如果是0则代表了接口调用失败 response.setReturnCode(2); response.setReturnMsg(NscUtils.getString(map.get(&quot;reason&quot;))); &#125;if(&quot;1&quot;.equals(NscUtils.getString(map.get(&quot;result&quot;)))) &#123;&#x2F;&#x2F;如果是1则代表了接口调用成功，设置成暂存待办 response.setReturnCode(4); response.setReturnMsg(&quot;等待银行处理结果&quot;); &#125;if(&quot;2&quot;.equals(NscUtils.getString(map.get(&quot;result&quot;)))) &#123;&#x2F;&#x2F;如果是2则代表了接口因为网络原因调用失败 response.setReturnCode(2); response.setReturnMsg(&quot;网络连接失败,请重试!&quot;); &#125; return response; &#125; @Override public String getNodeId() &#123; return &quot;2527015028921878665&quot;; &#125; @Override public String getNodeName() &#123; return &quot;银企直连付款报销接口&quot;; &#125; @Override public int getOrder() &#123; return 0; &#125; &#x2F;** * cap3表单获取超级节点上的数据 * @param params 传入数据 * @return 返回Map数据 *&#x2F; private Map&lt;String, Object&gt; getFormData(Map&lt;String, Object&gt; params) &#123; return (Map&lt;String, Object&gt;)params.get(&quot;CTP_FORM_DATA&quot;); &#125;&#125; 超级节点接口1234567891011121314151617181920212223242526272829303132333435363738&#x2F;*** * 超级节点状态修改接口 * 将超级节点的状态更改为完成 * @param tokenFormId 超级节点id * @param returnCode 超级节点状态码 * @param sqr 处理人id * @param msg 超级节点消息 * @return 返回1表示接口调用成功 *&#x2F;public int updateNodeState(String tokenFormId,int returnCode,Long sqr,String msg) &#123; String memberName &#x3D; getLoginName(sqr); CTPRestClient client &#x3D; ClientUtil.resouresClent(); log.info(&quot;updateNodeState:&quot;+tokenFormId+&quot;,&quot;+returnCode+&quot;,&quot;+sqr+&quot;,&quot;+msg+&quot;,&quot;+memberName); Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;(); map.put(&quot;message&quot;, msg);&#x2F;&#x2F;超级节点返回消息 map.put(&quot;returnCode&quot;, returnCode);&#x2F;&#x2F;超级节点状态码 0是暂存待办 1为通过 2就是回退 map.put(&quot;memberId&quot;,sqr);&#x2F;&#x2F;必须要传递，如果没有就传null，禁止字符串,如果传id就传long类型 map.put(&quot;memberName&quot;, memberName);&#x2F;&#x2F;必选 log.info(&quot;updateNodeState:&quot;+map); Integer post &#x3D; client.post(&quot;flow&#x2F;notification&#x2F;&quot; + tokenFormId, map,Integer.class); return post;&#125; &#x2F;*** * 根据登录人员id获取登录名 * @param sqr * @return *&#x2F;public String getLoginName(Long sqr) &#123; OrgManager orgManager &#x3D; ((OrgManager)AppContext.getBean(&quot;orgManager&quot;)); String LoginName &#x3D; &quot;&quot;; try &#123; V3xOrgMember memberById &#x3D; orgManager.getMemberById(sqr); LoginName &#x3D; memberById.getLoginName(); &#125; catch (BusinessException e) &#123; e.printStackTrace(); &#125; return LoginName;&#125; 超级节点状态码127.0之前 待验证7.1 1 - 流程往后流转 2 -回退流程 3 - 转干预人处理 4 - 等待外部调用 超级节点的数据表7.1 12WF_SUPERNODE_CONTROL 工作流超级节点控制表wf_supernode_control_detail 工作流超级节点执行详细","categories":[],"tags":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"}]},{"title":"Java中Https接口调用方法","slug":"Java中Https接口调用方法","date":"2020-07-21T09:30:17.000Z","updated":"2020-07-21T09:44:46.034Z","comments":true,"path":"2020/07/21/Java中Https接口调用方法/","link":"","permalink":"http://fangpengcheng.com/2020/07/21/Java%E4%B8%ADHttps%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"https介绍HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 [1] 。HTTPS 在HTTP 的基础下加入SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.URL;import java.security.KeyManagementException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.KeyManager;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSession;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;import org.apache.commons.logging.Log;import com.seeyon.ctp.common.log.CtpLogFactory;&#x2F;** * Https请求 * @author mszhou * *&#x2F;@SuppressWarnings(&quot;all&quot;)public class HttpsUtils &#123; private static final Log log &#x3D; CtpLogFactory.getLog(HttpsUtils.class); public static final class DefaultTrustManager implements X509TrustManager &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return null; &#125; &#125; public static HttpsURLConnection getHttpsURLConnection(String uri, String method)&#123; SSLContext ctx &#x3D; null; try &#123; ctx &#x3D; SSLContext.getInstance(&quot;TLS&quot;); ctx.init(new KeyManager[0], new TrustManager[] &#123; new DefaultTrustManager() &#125;, new SecureRandom()); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; SSLSocketFactory ssf &#x3D; ctx.getSocketFactory(); URL url&#x3D;null; HttpsURLConnection httpsConn &#x3D; null; try &#123; url &#x3D; new URL(uri); httpsConn&#x3D;(HttpsURLConnection)url.openConnection(); httpsConn.setConnectTimeout(3000); &#x2F;&#x2F; 设置超时时间 httpsConn.setSSLSocketFactory(ssf); httpsConn.setRequestProperty(&quot;Content-Type&quot;,&quot;application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8&quot;); httpsConn.setRequestProperty(&quot;Authorization&quot;,&quot;username&quot;); httpsConn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.11 (KHTML, like Gecko) Chrome&#x2F;23.0.1271.95 Safari&#x2F;537.11&quot;); &#x2F;* 在握手期间，如果 URL 的主机名和服务器的标识主机名不匹配， 则验证机制可以回调此接口的实现程序来确定是否应该允许此连接。 策略可以是基于证书的或依赖于其他验证方案。 当验证 URL 主机名使用的默认规则失败时使用这些回调。 *&#x2F; httpsConn.setHostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String arg0, SSLSession arg1) &#123; return true; &#125; &#125;); httpsConn.setRequestMethod(method); httpsConn.setDoInput(true); httpsConn.setDoOutput(true); &#125; catch (IOException e) &#123; log.error(&quot;网络连接失败：&quot;+e.getMessage()); &#125; return httpsConn; &#125; public static byte[] getBytesFromStream(InputStream is)&#123; ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(); byte[] kb &#x3D; new byte[1024]; int len; try &#123; while ((len &#x3D; is.read(kb)) !&#x3D; -1) &#123; baos.write(kb, 0, len); &#125; byte[] bytes&#x3D;baos.toByteArray();&#x2F;&#x2F;创建一个新分配的字节数组。数组的大小和当前输出流的大小，内容是当前输出流的拷贝。 return bytes; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (baos!&#x3D;null) &#123; try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (is!&#x3D;null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125; public static void setBytesToStream(OutputStream os, byte[] bytes)&#123; ByteArrayInputStream bais &#x3D; new ByteArrayInputStream(bytes); String string &#x3D; new String(bytes); byte[] kb &#x3D; new byte[1024]; int len; try &#123; while ((len &#x3D; bais.read(kb)) !&#x3D; -1) &#123; os.write(kb, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (os!&#x3D;null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (bais!&#x3D;null) &#123; try &#123; bais.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static byte[] doGet(String uri) throws IOException &#123; HttpsURLConnection httpsConn &#x3D; getHttpsURLConnection(uri, &quot;GET&quot;); return getBytesFromStream(httpsConn.getInputStream()); &#125; public static byte[] doPost(String uri, String data) throws IOException &#123; HttpsURLConnection httpsConn &#x3D; getHttpsURLConnection(uri, &quot;POST&quot;); setBytesToStream(httpsConn.getOutputStream(),data.getBytes(&quot;utf-8&quot;)); return getBytesFromStream(httpsConn.getInputStream()); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Eclipse中Xml错误","slug":"Eclipse中Xml错误","date":"2020-07-02T06:32:55.000Z","updated":"2020-07-02T06:36:24.591Z","comments":true,"path":"2020/07/02/Eclipse中Xml错误/","link":"","permalink":"http://fangpengcheng.com/2020/07/02/Eclipse%E4%B8%ADXml%E9%94%99%E8%AF%AF/","excerpt":"","text":"错误显示Referenced file contains errors (http://www.springframework.org/schema/beans/spring-beans-3.0.xsd) 解决办法删除缓存Preferences -&gt; General -&gt; Network Connections -&gt; Cache删除完成后project -&gt;下clean清理一下 然后刷新项目 版本不一致当前使用的spring版本和配置文件写的不同意，导致xsd等文件不会被正确加载，那么就是改成当前使用的对应版本了 格式不统一在使用spring时，使用多个配置文件，那么头里面的配置一定要统一，和上一种理论相同","categories":[],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://fangpengcheng.com/tags/Eclipse/"}]},{"title":"Java中数组和集合的比较","slug":"Java中数组和集合的比较","date":"2020-07-01T06:22:29.000Z","updated":"2020-07-02T06:36:29.567Z","comments":true,"path":"2020/07/01/Java中数组和集合的比较/","link":"","permalink":"http://fangpengcheng.com/2020/07/01/Java%E4%B8%AD%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"","text":"当需要在程序中记录单个数据内容时，则声明一个变量即可;当需要在程序中记录多个类型相同的数据内容时，则声明一个一维数据即可;当需要在程序中记录多个类型不相同的数据内容时，则构造一个对象即可;当需要在程序中记录多个类型相同的对象时，则可以声明一个对象数组即可;当需要在程序中记录多个类型不相同的对象时，则声明一个集合即可; 数组的特点a.数组本质上就是一段连续的内存空间，一旦创建则内存空间的容量固定不变;b.支持下标访问，便于实现随机访问;c.增删元素不方便，可能需要移动大量的元素;d.元素类型可以是基本数据类型，也可以是引用数据类型 集合的特点a.内存空间部分连续，部分不连续，容量可以动态调整;b.部分支持下标访问，部分不支持;c.增删元素可以不移动大量的元素;d.元素类型必须是引用数据类型，基本类型必须使用包装类;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的集合类","slug":"Java的集合类","date":"2020-07-01T06:13:29.000Z","updated":"2020-07-24T09:48:12.112Z","comments":true,"path":"2020/07/01/Java的集合类/","link":"","permalink":"http://fangpengcheng.com/2020/07/01/Java%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/","excerpt":"","text":"基本概念Java语言中集合框架的顶层接口是：java.util.Collection 和 java.util.Map。其中Collection接口中存放元素的基本单位是：单个元素。其中Map接口中存放元素的基本单位是：单对元素。在以后的开发中很少直接使用Collection接口，而是更多的使用该接口的子接口：List接口、Queue接口以及Set接口。 Collection接口的常用方法boolean add(E e) 用于将参数指定的元素e放入当前集合中。boolean addAll(Collection&lt;? extends E&gt; c) 用于将参数集合c中的所有元素放入当前集合中。123456789101112131415161718192021222324252627282930&#x2F;&#x2F;1.声明Collection类型的引用指向实现类的对象，形成多态&#x2F;&#x2F;Collection c1 &#x3D; new Collection(); error Collection是接口不能构造对象Collection c1 &#x3D; new ArrayList();&#x2F;&#x2F;打印集合中的所有内容，自动调用ArrayList类中的toString()方法&#x2F;&#x2F;默认打印格式为:[元素1,元素2,···]System.out.println(c1);&#x2F;&#x2F;[]&#x2F;&#x2F;2.向集合中添加单个元素boolean b1 &#x3D; c1.add(new String(&quot;One&quot;));System.out.println(c1);&#x2F;&#x2F;[One]System.out.println(b1);&#x2F;&#x2F;trueboolean b2 &#x3D; c1.add(new Integer(2));System.out.println(c1);&#x2F;&#x2F;[One, 2]System.out.println(b2);&#x2F;&#x2F;true&#x2F;&#x2F;当打印集合中的所有元素时，本质上就是让每个元素调用自己类型的toString()方法&#x2F;&#x2F;3.实现指定集合中的所有元素都放入到当前集合中&#x2F;&#x2F;准备另外一个集合Collection c2 &#x3D; new ArrayList();c2.add(&quot;three&quot;);c2.add(4);&#x2F;&#x2F;自动装箱机制System.out.println(&quot;c2&#x3D;&quot;+c2);&#x2F;&#x2F;c2&#x3D;[three, 4]&#x2F;&#x2F;将集合c2中的所有元素放入集合c1中，原则是将c2中的元素一个个添加到c1中b1 &#x3D;c1.addAll(c2);System.out.println(b1);&#x2F;&#x2F;trueSystem.out.println(c1);&#x2F;&#x2F;[One, 2, three, 4]&#x2F;&#x2F;将集合c2看做一个对象，整体放入集合c1中c1.add(c2);System.out.println(c1);&#x2F;&#x2F;[One, 2, three, 4, [three, 4]] boolean contains(Object o) 用于判断当前集合是否包含参数指定的单个元素。 如果此 collection 包含指定的元素，则返回 true。更确切地讲，当且仅当此 collection 至少包含一个满足 (o==null ? e==null : o.equals(e)) 的元素 e 时，返回 true。 boolean containsAll(Collection&lt;?&gt; c) 用于判断是否包含参数c中的所有元素。1234567891011121314151617181920212223242526272829303132333435363738394041 &#x2F;&#x2F;1.声名Collection类型的引用指向实现类的对象，形成多态 Collection c1 &#x3D; new ArrayList(); &#x2F;&#x2F;2.向集合中添加元素并打印 c1.add(&quot;one&quot;); c1.add(2); c1.add(new Student(1004,&quot;zhangfei&quot;,30)); System.out.println(&quot;c1&#x3D;&quot;+c1); &#x2F;&#x2F;c1&#x3D;[one, 2, Student [id&#x3D;1004, name&#x3D;zhangfei, age&#x3D;30]] &#x2F;&#x2F;3.准备另外一个集合,将集合中的所有元素添加集合中 Collection c2 &#x3D; new ArrayList(); c2.add(3); c2.add(&quot;four&quot;); System.out.println(c2);&#x2F;&#x2F;[3, four] c1.addAll(c2);&#x2F;&#x2F;相当于 将c2中的元素取出来，一个一个放到c1中&#x2F;&#x2F; c1.add(c2);&#x2F;&#x2F;相当于 c2为钱包，c1为书包，将钱包放到书包中 System.out.println(c1);&#x2F;&#x2F;[one, 2, Student [id&#x3D;1004, name&#x3D;zhangfei, age&#x3D;30], 3, four] System.out.println(&quot;---------------&quot;); &#x2F;&#x2F;4.判断当前集合中是否存在参数指定的单个元素 boolean contains &#x3D; c1.contains(1); System.out.println(contains);&#x2F;&#x2F;false boolean contains2 &#x3D; c1.contains(2); System.out.println(contains2);&#x2F;&#x2F;true &#x2F;&#x2F; collection 发法的执行原理 (o&#x3D;&#x3D;null ? e&#x3D;&#x3D;null : o.equals(e)) 的元素 e 时，返回 true。 &#x2F;&#x2F;其中o是形参变量，代表要查找的目标元素 &#x2F;&#x2F;若查找的目标元素为null，则在判断当前集合中是否有一个元素为null即可 &#x2F;&#x2F;若查找的目标元素不为null。则使用目标元素调用的equals()方法与集合中的所有元素依此比较是否相等 &#x2F;&#x2F;由于Student类没有重写equals()方法，因此调用从Object继承的方法，比较的是地址 false &#x2F;&#x2F;为了比较内容，则应该重写equals()方法 boolean contains3 &#x3D; c1.contains(new Student(1004,&quot;zhangfei&quot;,30)); System.out.println(contains3);&#x2F;&#x2F;false true &#x2F;&#x2F;5.判断参数指定集合中的所有元素是否存在 &#x2F;&#x2F;用于判断c1中是否包含c2中元素 boolean b1 &#x3D; c1.containsAll(c2);&#x2F;&#x2F;c1.addAll(c2); 使用该方法为true System.out.println(b1);&#x2F;&#x2F;true false &#x2F;&#x2F;笔试题 用于判断c1中是否包含c2这个元素整体 boolean contains4 &#x3D; c1.contains(c2);&#x2F;&#x2F;c1.add(c2); 使用该方法true System.out.println(contains4);&#x2F;&#x2F;false true boolean remove(Object o) 用于将参数指定的单个元素从当前集合删除。boolean removeAll(Collection&lt;?&gt; c) 用于删除参数集合中的所有元素。void clear() 用于清空当前集合中的所有元素。1234567891011121314&#x2F;&#x2F;[one, 2, Student [id&#x3D;1004, name&#x3D;zhangfei, age&#x3D;30], 3, four, [3, four]]System.out.println(c1);&#x2F;&#x2F;删除单个元素&#x2F;&#x2F;[one, 2, 3, four, [3, four]]c1.remove(new Student(1004,&quot;zhangfei&quot;,30));System.out.println(c1);&#x2F;&#x2F;删除多个元素&#x2F;&#x2F;[one, 2, [3, four]]c1.removeAll(c2);System.out.println(c1);&#x2F;&#x2F;清空集合&#x2F;&#x2F;[]c1.clear();System.out.println(c1); int size() 用于获取集合中的元素个数。 12345int c1Size &#x3D; c1.size();System.out.println(c1Size);&#x2F;&#x2F;0int c2Size &#x3D; c2.size();System.out.println(c2Size);&#x2F;&#x2F;2 boolean isEmpty() 用于判断当前集合是否为空。12345boolean c1Empty &#x3D; c1.isEmpty();System.out.println(c1Empty);&#x2F;&#x2F;trueboolean c2Empty &#x3D; c2.isEmpty();System.out.println(c2Empty);&#x2F;&#x2F;false boolean retainAll(Collection&lt;?&gt; c) 用于计算调用对象和参数对象的交集并保留到当前集合中，覆盖原有数据。 当前集合中的元素若发生改变则返回true，否则返回false。12345678System.out.println(&quot;c1:&quot;+c1);&#x2F;&#x2F;c1:[]System.out.println(&quot;c2:&quot;+c2);&#x2F;&#x2F;c2:[3, four]&#x2F;&#x2F;计算集合c2和集合c2的交集 ，交集结果还是自己c2.retainAll(c2);System.out.println(c2);&#x2F;&#x2F;[3, four]&#x2F;&#x2F;计算集合c2和集合c1的交集,交集的结果是空c2.retainAll(c1);System.out.println(c2);&#x2F;&#x2F;[]","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的多态使用场合","slug":"Java的多态使用场合","date":"2020-07-01T05:37:14.000Z","updated":"2020-07-21T08:35:25.274Z","comments":true,"path":"2020/07/01/Java的多态使用场合/","link":"","permalink":"http://fangpengcheng.com/2020/07/01/Java%E7%9A%84%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88/","excerpt":"","text":"什么是多态多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。 多态的使用场合通过方法的参数的传递形成多态12345public static void printPerson(Person p)&#123;&#125;printPerson(new Worker(&quot;zhangfei&quot;,30,3000)); 在方法体中直接使用父类的引用指向子类的对象形成多态12Account acc &#x3D; new FixedAccount(1000);acc.getLixi(); 通过方法的返回值形成多态public Calendar getInstance(){ retrun new GregorianCalendar();}","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的Calendar类","slug":"Java的Calendar类","date":"2020-07-01T02:39:36.000Z","updated":"2020-07-01T03:05:30.846Z","comments":true,"path":"2020/07/01/Java的Calendar类/","link":"","permalink":"http://fangpengcheng.com/2020/07/01/Java%E7%9A%84Calendar%E7%B1%BB/","excerpt":"","text":"基本概念 java.util.Calendar类用于描述特定的瞬间，来取代Date类中的过时方法。 该类是个抽象类，因此该类不能构造对象。 常用的方法static Calendar getInstance()- 用于获取Calendar类型的引用并返回。void set(int year, int month, int date, int hourOfDay, int minute, int second)- 用于设置年月日时分秒信息。 Date getTime()- 用于将Calendar类型的时间转换为Date类型的对象并返回。123456789101112131415161718192021222324252627&#x2F;&#x2F;1.使用过时的方式按照指定的年月日时分秒来构造独享并打印Date d1 &#x3D; new Date(2008,8,8,20,8,8);&#x2F;&#x2F;调整格式SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sdf.format(d1));&#x2F;&#x2F;3908-09-08 20:08:08&#x2F;&#x2F;输出结果发现与实际输出不符&#x2F;** year - 减 1900 的年份。 month - 0-11 之间的月份。 date - 一月中 1-31 之间的某一天。 hrs - 0-23 之间的小时数。 min - 0-59 之间的分钟数。 sec - 0-59 之间的秒数。 *&#x2F;Date d2 &#x3D; new Date(2008-1900,8-1,8,20,8,8);&#x2F;&#x2F;年减去1900，月-1&#x2F;&#x2F;调整格式System.out.println(sdf.format(d2));&#x2F;&#x2F;2008-08-08 20:08:08&#x2F;&#x2F;2 使用取代方法按照指定年月日时分秒来构造对象并打印&#x2F;&#x2F;2.1通过静态方法得到Calendar类型的引用Calendar c1 &#x3D; Calendar.getInstance();&#x2F;&#x2F;2.2通过set()方法来设置年月日时分秒信息c1.set(2008, 8-1, 8, 20, 8, 8);&#x2F;&#x2F;2.3通过getTime()方法转换Date类型Date time &#x3D; c1.getTime();&#x2F;&#x2F;2.4通过format()方法来调整格式System.out.println(sdf.format(time));&#x2F;&#x2F;2008-08-08 20:08:08","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的SimpleDateFormat类","slug":"Java的SimpleDateFormat类","date":"2020-07-01T02:11:23.000Z","updated":"2020-07-13T05:40:43.759Z","comments":true,"path":"2020/07/01/Java的SimpleDateFormat类/","link":"","permalink":"http://fangpengcheng.com/2020/07/01/Java%E7%9A%84SimpleDateFormat%E7%B1%BB/","excerpt":"","text":"基本概念SimpleDateFormat是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。 常用方法SimpleDateFormat(String pattern) 根据参数指定的模式来构造对象。 常用模式有：y-年,M-月,d-日,H-时,m-分,s-秒public final String format(Date date) 用于实现Date类型向String类型的转换。Date parse(String source) 用于实现String类型向Date类型的转换。 123456789101112&#x2F;&#x2F;使用默认日期打印出来Date d1 &#x3D; new Date();System.out.println(&quot;d1&#x3D;&quot;+d1);&#x2F;&#x2F;d1&#x3D;Wed Jul 01 10:31:18 CST 2020&#x2F;&#x2F;使用SimpleDateFormat类实现日期输出格式的调整SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);&#x2F;&#x2F;日期类型向字符串类型转换String format &#x3D; sdf.format(d1);System.out.println(format);&#x2F;&#x2F;2020-07-01 10:34:07&#x2F;&#x2F;字符串类型向日期类型转换Date parse &#x3D; sdf.parse(format);&#x2F;&#x2F;parse&#x3D;Wed Jul 01 10:35:03 CST 2020System.out.println(&quot;parse&#x3D;&quot;+parse); 格林威治时间时间是String类型123456789String date &#x3D; &quot;Mon Jul 13 00:00:00 CST 2020&quot;;SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;EEE MMM dd HH:mm:ss z yyyy&quot;,Locale.US);Date d &#x3D; null;try &#123; d &#x3D; sdf.parse(date);&#125; catch (ParseException e) &#123; e.printStackTrace();&#125;String format &#x3D; yyyyMMddHHmm.format(d);","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的日期类","slug":"Java的日期类","date":"2020-06-29T09:30:23.000Z","updated":"2020-07-01T02:12:00.644Z","comments":true,"path":"2020/06/29/Java的日期类/","link":"","permalink":"http://fangpengcheng.com/2020/06/29/Java%E7%9A%84%E6%97%A5%E6%9C%9F%E7%B1%BB/","excerpt":"","text":"基本概念java.util.Date类用于描述特征的瞬间，可以精确到毫秒数。 常用的方法Date() - 使用无参的方式构造对象，默认采用当前系统时间来初始化。 123&#x2F;&#x2F;1.使用无参方式构造对象并打印Date d1 &#x3D; new Date();System.out.println(&quot;d1 &#x3D;&quot; + d1);&#x2F;&#x2F;Tue Jun 30 17:37:22 CST 2020 Date(long date) - 根据参数指定的毫秒数来构造对象。 - 其中参数为距离1970年1月1日0时0分0秒以来的毫秒数。 - 1秒 = 1000毫秒 - 与后期要学的File类中的方法搭配使用。 123&#x2F;&#x2F;使用有参方式构造对象并打印Date d2 &#x3D; new Date(1000);System.out.println(&quot;d2 &#x3D;&quot; +d2);&#x2F;&#x2F;Thu Jan 01 08:00:01 CST 1970 long getTime() - 用于获取当前调用对象距离1970年1月1日0时0分0秒的毫秒数。 123&#x2F;&#x2F;3.获取调用对象距离标准时间的毫秒数long time &#x3D; d1.getTime();System.out.println(&quot;当前系统时间距离标准时间的毫秒数:&quot;+time);&#x2F;&#x2F;1593510001923 void setTime(long time) - 用于设置当前调用对象的时间为距离1970年1月1日0时0分0秒的毫秒数。 123&#x2F;&#x2F;4.设置调用对象d1的时间距离标准时间2秒的时间点d1.setTime(2000);System.out.println(&quot;d2 &#x3D;&quot; +d1);&#x2F;&#x2F;Thu Jan 01 08:00:02 CST 1970","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的StringBuilder类和StringBuffer类","slug":"Java的StringBuilder类和StringBuffer类","date":"2020-06-24T01:56:40.000Z","updated":"2020-06-29T09:29:41.522Z","comments":true,"path":"2020/06/24/Java的StringBuilder类和StringBuffer类/","link":"","permalink":"http://fangpengcheng.com/2020/06/24/Java%E7%9A%84StringBuilder%E7%B1%BB%E5%92%8CStringBuffer%E7%B1%BB/","excerpt":"","text":"概念由于String类描述的字符串内容是个常量不可改变，若程序中出现大量相似的字符串时使用String类型描述则需要单独存储，此时对内存空间的消耗比较大。为了解决上述问题，希望直接修改字符串内容，则使用StringBuilder类或StringBuffer类加以描述。其中StringBuffer类从jdk1.0开始出现，属于线程安全的类，因此效率比较低；其中StringBuilder类从jdk1.5开始出现，属于非线程安全的类，因此效率比较高； 常用的方法由于StringBuilder类与StringBuffer类的方法基本一样 这里展示的为StringBuilder。 StringBuilder(String str)-根据指定字符串来构造对象，其中初始容量为：字符串长度+16 int capacity() 用于返回调用对象的容量int length() 用于返回调用对象的长度/字符的个数12345&#x2F;&#x2F;1.声明StringBuilder类型的引用指向该类型的对象StringBuilder sb1&#x3D; new StringBuilder(&quot;hello&quot;);&#x2F;&#x2F;2.获取该对象的容量和长度并打印System.out.println(&quot;调用对象的容量是：&quot; + sb1.capacity()); &#x2F;&#x2F;21&#x3D;5+16System.out.println(&quot;调用对象的长度是：&quot; + sb1.length()); &#x2F;&#x2F;5 StringBuilder insert(int offset, String str) 用于将参数str代表的内容插入到当前字符串中下标为offset中。返回当前对象的引用123456789101112131415161718&#x2F;&#x2F;字符串方法String s1 &#x3D; &quot;hello&quot;;String upperCase &#x3D; s1.toUpperCase();&#x2F;&#x2F;使用字符串方法会返回一个新的字符串System.out.println(upperCase);&#x2F;&#x2F;HELLO System.out.println(s1);&#x2F;&#x2F;hello &#x2F;&#x2F;3.调用insert方法向字符串中插入字符串内容&#x2F;&#x2F;向字符串开头位置(下标0)插入abcdStringBuilder insert &#x3D; sb1.insert(0, &quot;abcd&quot;);&#x2F;&#x2F;这里返回的是当前的值对象System.out.println(insert);&#x2F;&#x2F;abcdhelloSystem.out.println(sb1);&#x2F;&#x2F;abcdhello &#x2F;&#x2F;向中间位置插入字符串内容sb1.insert(4, &quot;1234&quot;);System.out.println(&quot;sb1 &#x3D; &quot; + sb1); &#x2F;&#x2F;abcd1234hello&#x2F;&#x2F;向末尾位置插入字符串内容sb1.insert(sb1.length(), &quot;ABCDi&quot;);System.out.println(&quot;sb1 &#x3D; &quot; + sb1); &#x2F;&#x2F;abcd1234helloABCD StringBuilder append(String str) 用于将参数str代表的内容插入到当前字符串末尾中，返回当前对象的引用123456&#x2F;&#x2F;4.实现向字符串末尾追加数据内容sb1.append(&quot;world&quot;);System.out.println(&quot;sb1 &#x3D; &quot; + sb1);&#x2F;&#x2F;sb1 &#x3D; abcd1234helloABCDiworld&#x2F;&#x2F;当插入的字符串内容超过了初始容量时会自动扩容，而扩容的具体算法需要查看源码System.out.println(&quot;调用对象的容量是：&quot; + sb1.capacity()); &#x2F;&#x2F;44System.out.println(&quot;调用对象的长度是：&quot; + sb1.length()); &#x2F;&#x2F;22 StringBuilder delete(int start, int end)-用于将当前字符串中从start（包含）到end（不包含）的 12345678910111213141516&#x2F;&#x2F;5.实现字符串内容的删除&#x2F;&#x2F;删除中间内容。起始下标8，结尾下标13，包含8不包含13StringBuilder delete &#x3D; sb1.delete(8, 13);System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;abcd1234ABCDiworld&#x2F;&#x2F;删除开头位置 [0,4)sb1.delete(0, 4);System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;1234ABCDiworld&#x2F;&#x2F;删除结尾位置sb1.delete(8, sb1.length());System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;1234ABCD&#x2F;&#x2F;删除单个字符sb1.deleteCharAt(3);System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;123ABCD&#x2F;&#x2F;删除全部内容sb1.delete(0, sb1.length());System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F; StringBuilder replace(int start, int end, String str)-用于将当前字符串中从start到end位置之间的内容用str替换掉 1234567891011121314&#x2F;&#x2F;替换中间内容sb1.replace(8, 13, &quot;replace&quot;);System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;abcd1234replaceABCDiworld&#x2F;&#x2F;替换开头sb1.replace(0, 4, &quot;poiu&quot;);System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;poiu1234replaceABCDiworld&#x2F;&#x2F;替换结尾sb1.replace(8, sb1.length(), &quot;987654321&quot;);System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;poiu1234987654321&#x2F;&#x2F;替换全部sb1.replace(0, sb1.length(), &quot;qwe&quot;);System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;qweSystem.out.println(&quot;调用对象的容量是：&quot; + sb1.capacity()); &#x2F;&#x2F;44System.out.println(&quot;调用对象的长度是：&quot; + sb1.length()); &#x2F;&#x2F;3 void setCharAt(int index, char ch) 用于将当前字符串中下标为index位置的单个字符串修改为参数ch的数值123&#x2F;&#x2F;修改指定位置的单个字符sb1.setCharAt(0, &#39;a&#39;);System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;awe int indexOf(String str) 用于当前字符串中查找参数str第一次出现的索引位置.1234&#x2F;&#x2F;7.查找System.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;abcd1234helloABCDiworldint indexOf &#x3D; sb1.indexOf(&quot;ABCD&quot;);System.out.println(indexOf);&#x2F;&#x2F;13, StringBuilder reverse() 实现字符串的反转，返回当前对象的引用 123StringBuilder reverse &#x3D; sb1.reverse();System.out.println(reverse);&#x2F;&#x2F;dlrowiDCBAolleh4321dcbaSystem.out.println(&quot;sb1&#x3D;&quot;+sb1);&#x2F;&#x2F;dlrowiDCBAolleh4321dcba 如何实现String和StringBuilder之间的转换//8.String转换StringBuilder String str =&quot;string&quot;; StringBuilder strB = new StringBuilder(str); System.out.println(strB);//string //9.String转换StringBuilder String strc = strB.toString(); System.out.println(strc);//string","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-06-22T09:37:18.000Z","updated":"2020-06-24T01:33:13.426Z","comments":true,"path":"2020/06/22/正则表达式/","link":"","permalink":"http://fangpengcheng.com/2020/06/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"概念正则表达式本质上就是一个字符串，对于用户输入的数据内容进行格式的验证。该字符串通常使用~符号作为开头标志，使用$符号作为结尾标志，也可以省略标志。 常用的规则[abc] - 表示可以出现a、b 或 c（简单类）。[^abc] - 表示可以出现任何字符，除了 a、b 或 c（否定）。[a-zA-Z] - 表示可以出现a 到 z 或 A 到 Z，两头的字母包括在内（范围）。所有字母 \\d - 表示可以出现任何数字，相当于[0-9]。\\D - 表示可以出现任何非数字，相当于[^0-9]。\\s - 表示可以出现任何空白字符：[ \\t\\n\\x0B\\f\\r]\\S - 表示可以出现任何非空白字符：[^\\s]。\\w - 表示可以出现任何单词字符：[a-zA-Z_0-9],由字母数字下划线组成\\W - 表示可以出现任何非单词字符：[^\\w] X? - 表示X可以出现一次或一次也没有，也就是0 ~ 1次。X* - 表示X可以出现零次或多次，也就是0 ~ n次。X+ - 表示X可以出现一次或多次，也就是1 ~ n次。X{n} - 表示X可以出现恰好 n 次。X{n,} - 表示X可以出现至少 n 次，也就是&gt;=n次。X{n,m} - 表示X可以出现至少 n 次，但是不超过 m 次，也就是&gt;=n次并且&lt;=m次。 (3)相关的方法 boolean matches(String regex) - 用于判断当前字符串内容是否满足参数指定的规则。 123456789101112131415161718192021&#x2F;&#x2F;1.准备描述正则表达式规则的字符串&#x2F;&#x2F;描述银行卡密码规则，要求6位数字&#x2F;&#x2F;String reg &#x3D; &quot;^[0-9]&#123;6&#125;$&quot;;&#x2F;&#x2F;String reg &#x3D; &quot;^\\\\d&#123;6&#125;$&quot;;&#x2F;&#x2F;手机号的密码规则11位数字，必须是1开头，第二位数字必须是3458&#x2F;&#x2F;String reg &#x3D; &quot;^[1]&#123;1&#125;[3458]&#123;1&#125;\\\\d&#123;9&#125;$&quot;;&#x2F;&#x2F;描述身份证号码 前6位数字是地区，4位数字为年份，2位数字是月份，2位数字日期，3位数字 最后一位是数字或x&#x2F;&#x2F;String reg &#x3D;&quot;^\\\\d&#123;6&#125;\\\\d&#123;4&#125;\\\\d&#123;2&#125;\\\\d&#123;2&#125;\\\\d&#123;3&#125;[0-9|x]&#123;1&#125;$&quot;;&#x2F;&#x2F;描述邮箱规则 fangpengcheng_123@qq.comString reg &#x3D; &quot;^\\\\w&#123;1,&#125;[@]&#123;1&#125;[0-9a-zA-Z]&#123;2,5&#125;(.com|.cn|.org|.com.cn|.edu)$&quot;;Scanner sc &#x3D; new Scanner(System.in);for(;;) &#123; System.out.println(&quot;请输入银行卡密码&quot;); String str &#x3D; sc.next(); if(str.matches(reg)) &#123; System.out.println(&quot;格式正确&quot;); break; &#125;else &#123; System.out.println(&quot;格式不正确&quot;); &#125;&#125; String[] split(String regex, int limit) -根据给定正则表达式的匹配拆分此字符串。 123String a &#x3D; &quot;fff 000 ccc 555&quot;;String[] split &#x3D; a.split(&quot;\\\\s&quot;);System.out.println(Arrays.toString(split)); 输出结果 1[fff, 000, ccc, 555] replaceAll(String regex, String replacement) -使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 123 String a &#x3D; &quot;fff 000 ccc 555&quot;;String replaceAll &#x3D; a.replaceAll(&quot;\\\\s&quot;, &quot;-&quot;);System.out.println(replaceAll); 输出结果 1fff-000-ccc-555","categories":[],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://fangpengcheng.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Java的String类","slug":"Java的String类","date":"2020-06-17T02:39:07.000Z","updated":"2020-06-22T09:25:38.939Z","comments":true,"path":"2020/06/17/Java的String类/","link":"","permalink":"http://fangpengcheng.com/2020/06/17/Java%E7%9A%84String%E7%B1%BB/","excerpt":"","text":"String基本概念java.lang.String类用于描述字符串,Java程序中的所有字符串字面值都可以使用该类的实例/对象加以描述，如：”hello”。该类描述的字符串串内容是个常量不可改变,因此可以被共享使用。该类由final关键字修饰 12String s1 &#x3D; &quot;hello&quot;;s1 &#x3D; &quot;world&quot;; --改变引用的指向而不是指向的内容 常量池由于字符串内容是个常量不可改变，因此Java虚拟机将程序中每次出现的字符串字面值放入常量池中，若下次再出现重复的字符串内容则直接使用池中对象即可而无需创新新的对象，从而提高性能 String类的方法构造方法String() - 使用无参方式构造对象得到空字符序列，如:””String(byte[] bytes, int offset, int length) - 使用bytes数组中下标从offset位置开始的length个字节来构造对象。String(byte[] bytes) - 使用bytes数组中的所有内容构造对象。String(char[] value, int offset, int count) - 使用value数组中下标从offset位置开始的count个字符来构造对象。String(char[] value) - 使用value数组中的所有内容构造对象。String(String original) - 根据参数指定的字符串内容来构造对象，新创建对象为参数对象的副本。 1234567891011121314151617181920212223242526&#x2F;&#x2F;1.使用无参的方式构造对象String s1&#x3D; new String();System.out.println(&quot;s1&#x3D;&quot;+s1);&#x2F;&#x2F;自动调用toString; s1&#x3D;&#x2F;&#x2F;2.使用字节数组来构造对象byte[] bArr&#x3D; &#123;97,98,99,100,101&#125;;&#x2F;&#x2F;使用字节数据中的一部分内容来构造字符串对象&#x2F;&#x2F;使用数据bArr中下标从1开始的3个字节来构造对象，bcdString s2 &#x3D; new String(bArr,1,3);System.out.println(&quot;s2&#x3D;&quot;+s2);&#x2F;&#x2F;s2&#x3D;bcd&#x2F;&#x2F;3.整个字节数据来构造对象String s3 &#x3D; new String(bArr);System.out.println(&quot;s3&#x3D;&quot;+s3);&#x2F;&#x2F;s3&#x3D;abcde&#x2F;&#x2F;4。字符数组来构造对象char[] cArr &#x3D; &#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;;String s4 &#x3D; new String(cArr,1,3);System.out.println(&quot;s4 &#x3D;&quot; +s4);&#x2F;&#x2F;s4 &#x3D;ell&#x2F;&#x2F;5.整个字符数组来构造对象String s5 &#x3D; new String(cArr);System.out.println(&quot;s5&#x3D;&quot;+s5);&#x2F;&#x2F;s5&#x3D;hello&#x2F;&#x2F;6.字符串构造字符串String s6 &#x3D; new String(&quot;123&quot;);System.out.println(&quot;s6&#x3D;&quot;+s6);&#x2F;&#x2F;s6&#x3D;123 常用方法该类重写了equals()、hashCode()以及toString()方法。 char charAt(int index) - 根据参数指定的下标返回对应的单个字符。 int length() - 用于返回当前字符串的长度。 123456789&#x2F;&#x2F;1.声明String类型的引用指向该类型的对象String s1 &#x3D; new String(&quot;GoodMorning!&quot;);&#x2F;&#x2F;2.打印字符串长度，取出该字符串中的每个字符串并打印&#x2F;&#x2F;数组名.length - 用于获取数组长度，切记没有() 因为数据的特征&#x2F;&#x2F;字符串.length - 用于获取字符串长度，切记有() 因为是成员方法的调用System.out.println(&quot;字符串的长度是:&quot; + s1.length());for (int i &#x3D; 0; i &lt; s1.length(); i++) &#123; System.out.println(&quot;下标为：&quot;+i+&quot;的单个字符是:&quot;+s1.charAt(i));&#125; 结果: 12345678910111213字符串的长度是:12下标为：0的单个字符是:G下标为：1的单个字符是:o下标为：2的单个字符是:o下标为：3的单个字符是:d下标为：4的单个字符是:M下标为：5的单个字符是:o下标为：6的单个字符是:r下标为：7的单个字符是:n下标为：8的单个字符是:i下标为：9的单个字符是:n下标为：10的单个字符是:g下标为：11的单个字符是:! int compareTo(String anotherString) - 用于比较调用对象和参数对象的大小关系。 - 使用调用对象和参数对象中第一个字符起依次做减法运算 - 若第一个字符能确定大小，则后续字符不用比较 - 若第一个字符不能确定大小，则使用下一个对应位置的字符比较大小。 - 直到其中一个字符串的所有字符比较完毕后也没有确定大小，则由长度来决定大小。 - 若当前字符串大则返回正数；若当前字符串小则返回负数；若相等则返回零；int compareToIgnoreCase(String str) - 不考虑大小写，也就是’a’和’A’是相等的关系。 boolean contains(CharSequence s) - 用于判断当前字符串是否包含参数指定的内容。 - 其中参数是接口类型，因此实参需要传递实现类的对象，而String类就实现了该接口 12345678&#x2F;&#x2F;1.声明String类型的引用指向String类型的对象String s1 &#x3D; new String(&quot; Let Me Give You Some Color To See See !&quot;);&#x2F;&#x2F;2.调用成员方法实现测试&#x2F;&#x2F;3.判断当前字符串是否包含指定内容boolean contains &#x3D; s1.contains(&quot;color&quot;);System.out.println(&quot;contains&#x3D;&quot;+contains);&#x2F;&#x2F;falseboolean contains2 &#x3D; s1.contains(&quot;Color&quot;);System.out.println(&quot;contains2&#x3D;&quot;+contains2);&#x2F;&#x2F;true boolean endsWith(String suffix) - 判断当前字符串是否以参数指定的内容为结尾。 12345&#x2F;&#x2F;判断当前字符是否以指定的内容结尾boolean endsWith &#x3D; s1.endsWith(&quot;See&quot;);System.out.println(&quot;endsWith&#x3D;&quot;+endsWith);&#x2F;&#x2F;falseboolean endsWith2 &#x3D; s1.endsWith(&quot;See!&quot;);System.out.println(&quot;endsWith2&#x3D;&quot;+endsWith2);&#x2F;&#x2F;true boolean startsWith(String prefix) - 判断当前字符串中是否以参数指定的内容为开头。 12345&#x2F;&#x2F;判断当前字符串是否以指定的内容开头boolean startsWith &#x3D; s1.startsWith(&quot;Let&quot;);System.out.println(startsWith);&#x2F;&#x2F;falseboolean startsWith2 &#x3D; s1.startsWith(&quot; &quot;);System.out.println(startsWith2);&#x2F;&#x2F;true String toLowerCase() - 用于将当前字符串中所有字符转换为小写。String toUpperCase() - 用于将当前字符串中所有字符转换为大写。 123456789&#x2F;**将所有的字符串转换成大写或小写字母并打印出来*&#x2F;String str &#x3D; new String(&quot;Hello Java World&quot;);System.out.println(&quot;原字符串：&quot; + str + &quot;\\n&quot;);&#x2F;*使用toUpperCase()方法实现大写转换*&#x2F;String newA &#x3D; str.toUpperCase();System.out.println(&quot;大写转换：&quot; + newA);&#x2F;*使用toLowerCase()方法实现小写转换*&#x2F;String newB &#x3D; str.toLowerCase();System.out.println(&quot;小写转换：&quot; + newB); String trim() - 用于去除当前字符串中两端的空白字符。 1234&#x2F;&#x2F;去除两端空白字符System.out.println(s1);&#x2F;&#x2F; Let Me Give You Some Color To See See! String trim &#x3D; s1.trim();System.out.println(trim);&#x2F;&#x2F;Let Me Give You Some Color To See See! boolean equals(Object anObject) - 用于比较字符串内容是否相等并返回； 12345678910111213141516171819&#x2F;&#x2F;用equals模拟登录Scanner sc &#x3D; new Scanner(System.in);for(int i&#x3D;3;i&gt;0;i--) &#123; System.out.println(&quot;请输入用户名和密码:&quot;); String userName &#x3D; sc.next(); String password &#x3D; sc.next(); if(&quot;admin&quot;.equals(userName) &amp;&amp; &quot;123456&quot;.equals(password)) &#123; System.out.println(&quot;登录成功，欢迎使用!&quot;); break; &#125; if(i &#x3D;&#x3D; 1) &#123; System.out.println(&quot;账户已经冻结,请联系客服人员！&quot;); break; &#125; System.out.println(&quot;用户名或密码错误，您还有&quot;+(i-1)+&quot;次机会&quot;);&#125; boolean equalsIgnoreCase(String anotherString) - 用于比较字符串内容是否相等并返回，不考虑大小写，如：’A’和’a’是相等。 12345&#x2F;&#x2F;用于比较字符串内容是否相等并返回，不考虑大小写，如：&#39;A&#39;和&#39;a&#39;是相等。String s1 &#x3D; new String(&quot;admin&quot;);System.out.println(&quot;admin&quot;.equalsIgnoreCase(s1));&#x2F;&#x2F;trueSystem.out.println(&quot;Admin&quot;.equalsIgnoreCase(s1));&#x2F;&#x2F;trueSystem.out.println(&quot;Admin&quot;.equals(s1));&#x2F;&#x2F;fasle byte[] getBytes() - 用于将当前字符串内容转换为byte数组并返回。 12345String s2 &#x3D; new String(&quot;123&quot;);byte[] bytes &#x3D; s2.getBytes();for (int i &#x3D; 0; i &lt; bytes.length; i++) &#123; System.out.print(bytes[i]);&#x2F;&#x2F; 123 &#x3D;》49 50 51 将字符串变成十进制的ascii码&#125; char[] toCharArray() - 用于将当前字符串内容转换为char数组并返回。 12345String s2 &#x3D; new String(&quot;123&quot;);char[] charArray &#x3D; s2.toCharArray();for (int i &#x3D; 0; i &lt; charArray.length; i++) &#123; System.out.println(charArray[i]);&#x2F;&#x2F;将字符串转换成字符&#125; int indexOf(int ch) - 用于返回当前字符串中参数ch指定的字符第一次出现的下标。 123String s1 &#x3D; new String(&quot;admina&quot;);int indexOf &#x3D; s1.indexOf(&#39;a&#39;);System.out.println(indexOf);&#x2F;&#x2F;0 int indexOf(int ch, int fromIndex) - 用于从fromIndex位置开始查找ch指定的字符,fromIndex位置后(包括fromIndex位置)第一次出现的下标。 - 上述方法若查找失败，则返回-1. 123 String s1 &#x3D; new String(&quot;admina&quot;); int indexOf &#x3D; s1.indexOf(&#39;a&#39;,2);System.out.println(indexOf);&#x2F;&#x2F;5 int indexOf(String str) - 用于查找参数str指定的字符串并返回下标,第一次出现的下标。 123String s1 &#x3D; new String(&quot;admina&quot;);int indexOf &#x3D; s1.indexOf(&quot;ad&quot;);System.out.println(indexOf);&#x2F;&#x2F;0 int indexOf(String str, int fromIndex) - 用于从fromIndex位置开始查找,fromIndex位置后(包括fromIndex位置)第一次出现的下标。 123String s1 &#x3D; new String(&quot;admina&quot;);int indexOf &#x3D; s1.indexOf(&quot;ad&quot;, 3);System.out.println(indexOf);&#x2F;&#x2F;5 int lastIndexOf(int ch) - 用于返回参数ch指定的字符最后一次出现的下标。int lastIndexOf(int ch, int fromIndex) - 用于从fromIndex位置开始查找ch指定字符出现的下标，反向搜索的第一次。int lastIndexOf(String str) - 用于返回str指定字符串最后一次出现的下标。int lastIndexOf(String str, int fromIndex) - 用于从fromIndex位置开始反向搜索的第一次。 1234System.out.println(s1.lastIndexOf(&#39;a&#39;));&#x2F;&#x2F;5System.out.println(s1.lastIndexOf(&#39;a&#39;,3));&#x2F;&#x2F;0System.out.println(s1.lastIndexOf(&quot;ad&quot;));&#x2F;&#x2F;5System.out.println(s1.lastIndexOf(&quot;ad&quot;,3));&#x2F;&#x2F;0 String substring(int beginIndex) - 用于获取当前字符串中从beginIndex位置开始的子字符串并返回。 String substring(int beginIndex, int endIndex) - 用于获取当前字符串中从beginIndex位置开始到endIndex结尾的子字符串并返回。 1234567String s1 &#x3D; new String(&quot;adminad&quot;);String substring &#x3D; s1.substring(2);&#x2F;&#x2F;从当前下标开始[2,结尾]System.out.println(substring);&#x2F;&#x2F;minadString substring2 &#x3D; s1.substring(2, 3);&#x2F;&#x2F;从当前下标开始,到指定下标的前一个,[2,3)System.out.println(substring2);&#x2F;&#x2F;m 练习题两种方式实现字符串向整数转换1234567891011String s2&#x3D;new String(&quot;12345&quot;);&#x2F;&#x2F;方法1 Integer包装类int parseInt &#x3D; Integer.parseInt(s2);System.out.println(parseInt);&#x2F;&#x2F;方法2:利用ASCII实现字符串向整数转换int ib &#x3D; 0;for (int i &#x3D; 0; i &lt; s2.length(); i++) &#123; ib &#x3D; ib*10 +(s2.charAt(i)-&#39;0&#39;);&#125; 注意事项“”和null之间的区别:a.””表示有字符串对象，但里面没有存放数据内容;b.null表示没有字符串对象，调用方法会引发空指针异常;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java数学处理类","slug":"Java数学处理类","date":"2020-06-16T12:49:52.000Z","updated":"2020-06-17T02:40:19.329Z","comments":true,"path":"2020/06/16/Java数学处理类/","link":"","permalink":"http://fangpengcheng.com/2020/06/16/Java%E6%95%B0%E5%AD%A6%E5%A4%84%E7%90%86%E7%B1%BB/","excerpt":"","text":"BigDecimal基本概念由于double类型再数据运算中可能存在误差，若希望实现精确的运算则使用java.math.BigDecimal类型加以描述。 常用方法BigDecimal(String val) - 根据参数指定的字符串构造对象。BigDecimal add(BigDecimal augend) - 计算调用对象和参数对象的和并返回。BigDecimal subtract(BigDecimal subtrahend) - 计算调用对象和参数对象的差并返回。BigDecimal multiply(BigDecimal multiplicand) - 计算调用对象和参数对象的积并返回。BigDecimal divide(BigDecimal divisor) - 计算调用对象和参数对象的商并返回。 BigDecimal b1 = new BigDecimal(&quot;5.2&quot;); BigDecimal b2 = new BigDecimal(&quot;1.3&quot;); System.out.println(&quot;和:&quot;+b1.add(b2));//6.5 System.out.println(&quot;差:&quot;+b1.subtract(b2));//3.9 System.out.println(&quot;积:&quot;+b1.multiply(b2));//6.76 System.out.println(&quot;商:&quot;+b1.divide(b2));//4 //使用BigDecimal进行精确运算 System.out.println(0.1+0.2);//0.30000000000000004 BigDecimal b3 = new BigDecimal(&quot;0.1&quot;); BigDecimal b4 = new BigDecimal(&quot;0.2&quot;); System.out.println(b3.add(b4));//0.3","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"OAM3端","slug":"OAM3端","date":"2020-06-12T04:05:29.000Z","updated":"2020-06-12T07:54:50.244Z","comments":true,"path":"2020/06/12/OAM3端/","link":"","permalink":"http://fangpengcheng.com/2020/06/12/OAM3%E7%AB%AF/","excerpt":"","text":"快速ajax12345678910111213141516171819202122cmp.ajax(&#123; type:&quot;GET&quot;, url:cmp.seeyonbasepath + &#39;&#x2F;ext&#x2F;NscZdyFpc.do?method&#x3D;AssociatedFoldersM3&#39;,&#x2F;&#x2F;url的拼接 headers:&#123; &#39;Accept&#39;:&#39;application&#x2F;json; charset&#x3D;utf-8&#39;, &#39;Accept-Language&#39; : cmp.language, &#39;Content-Type&#39;: &#39;application&#x2F;json; charset&#x3D;utf-8&#39;, &#39;option.n_a_s&#39; : &#39;1&#39; &#125;, success:function(result)&#123; alert(result); &#125;, error:function(error)&#123; if(!cmp.errorHandler(error))&#123; &#x2F;&#x2F;先调用平台的错误统一处理机制 &#x2F;&#x2F;如果平台的统一处理机制处理不了，则自己写业务逻辑 var code &#x3D; error.code; if(code&#x3D;&#x3D;500)&#123; alert(&quot;请求失败&quot;); &#125; &#125; &#125;&#125;); 调用restful接口1234567891011121314151617181920212223SeeyonApi.Rest.get(url, &#123;&#125;, &quot;&quot;, errorBuilder(&#123;success : function(result) &#123; if (&quot;true&quot; &#x3D;&#x3D;&#x3D; result.data) &#123; var updateData &#x3D; &#123; field0006: &#123; value : &#39;YES&#39;, showValue : &#39;YES&#39;, showValue2 : &#39;YES&#39; &#125; &#125; payload.updateData &#x3D; updateData; payload.privateId&#x3D;privateId; &#x2F;&#x2F; 初始化的时候已经定义好 实际也是依赖于adaptation和privateId adaptation.backCallApi(&#39;presave&#39;, function()&#123; adaptation.backfillFormControlData(payload, privateId); console.log(&#39;表单预提交成功&#39;); &#125;,payload); cmp.notification.close(); &#125;else&#123; cmp.notification.alert(&#39;密码错误！&#39;, &#39;&#39;, &#39;&#39;, &#39;确定&#39;); &#125;&#125;&#125;));","categories":[],"tags":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"}]},{"title":"hexo图片不显示","slug":"hexo图片不显示","date":"2020-06-11T09:12:39.000Z","updated":"2020-06-11T10:01:16.560Z","comments":true,"path":"2020/06/11/hexo图片不显示/","link":"","permalink":"http://fangpengcheng.com/2020/06/11/hexo%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/","excerpt":"","text":"修改配置文件1修改博客根目录中_config.yml文件的配置项post_asset_folder为true： 下载插件1npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save 图片代码示例123&lt;p&gt; &lt;img src&#x3D;&quot;文章名称&#x2F;图片名称.图片类型&quot; width&#x3D;&quot;500px&quot; height&#x3D;&quot;500px&quot;&gt;&lt;&#x2F;p&gt;","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://fangpengcheng.com/tags/Hexo/"}]},{"title":"eclipse设置工作空间","slug":"eclipse设置工作空间","date":"2020-06-11T08:58:08.000Z","updated":"2020-06-11T09:58:17.501Z","comments":true,"path":"2020/06/11/eclipse设置工作空间/","link":"","permalink":"http://fangpengcheng.com/2020/06/11/eclipse%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/","excerpt":"","text":"设置","categories":[],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://fangpengcheng.com/tags/Eclipse/"}]},{"title":"OA常用bean","slug":"OA常用bean","date":"2020-06-11T06:59:42.000Z","updated":"2020-06-11T08:54:40.433Z","comments":true,"path":"2020/06/11/OA常用bean/","link":"","permalink":"http://fangpengcheng.com/2020/06/11/OA%E5%B8%B8%E7%94%A8bean/","excerpt":"","text":"枚举类1EnumManager enumManagerNew &#x3D; ((EnumManager) AppContext.getBean(&quot;enumManagerNew&quot;)); 代码示例： 通过枚举表单枚举名称获取枚举id123456789101112131415161718192021222324&#x2F;** * 通过枚举表单枚举名称获取枚举id * * @param ftb 表单对象 * @param displayName 表单枚举字段域名name * @param showValue 表单枚举name * @return * @time 2020年4月8日 上午10:08:19 *&#x2F;public static Long getEnumItemByName(FormTableBean ftb, String displayName, String showValue) &#123; EnumManager enumManagerNew &#x3D; ((EnumManager) AppContext.getBean(&quot;enumManagerNew&quot;)); try &#123; CtpEnumItem enumI &#x3D; enumManagerNew.getItemByEnumId(ftb.getFieldBeanByDisplay(displayName).getEnumId(), showValue); if (enumI &#x3D;&#x3D; null) &#123; return null; &#125; else &#123; return enumI.getId(); &#125; &#125; catch (BusinessException e) &#123; log.error(&quot;getEnumItemByName:&quot;+e.getMessage()); return null; &#125;&#125; 文档表1DocHierarchyManager docHierarchyManager &#x3D; ((DocHierarchyManager) AppContext.getBean(&quot;docHierarchyManager&quot;)); 代码示例 判断文件是否存在1boolean exist &#x3D; docHierarchyManager.isExist(NscUtil.getLong(fileParent_id)); cap4对象1CAP4FormManager cap4FormManager &#x3D; ((CAP4FormManager) AppContext.getBean(&quot;cap4FormManager&quot;)); 代码示例 通过数据表获取cap4123456789FormDataMasterBean fdmb &#x3D; cap4FormManager.getSessioMasterDataBean(formRecordId);if (fdmb &#x3D;&#x3D; null) &#123; long formId &#x3D; colSummary.getFormAppid(); try &#123; fdmb &#x3D; cap4FormManager.getDataMasterBeanById(formRecordId, cap4FormManager.getForm(formId), null); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 获取当前登录用户信息1User user &#x3D; AppContext.getCurrentUser();","categories":[],"tags":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"}]},{"title":"Java的Object类","slug":"Java的Object类","date":"2020-06-09T13:13:44.000Z","updated":"2020-06-18T03:41:12.280Z","comments":true,"path":"2020/06/09/Java的Object类/","link":"","permalink":"http://fangpengcheng.com/2020/06/09/Java%E7%9A%84Object%E7%B1%BB/","excerpt":"","text":"Object类简介Object 是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。 常用方法super();无参构造对象，通常用于子类使用 boolean equals(Object obj)-调用对象是否和参数对象相等 比较两个对象的地址（相等对象必须具有相等的哈希码）-若希望该方法比较两个对象的内容，则需要重写该方法-当该方法重写时，有必要重写hashcode()方法 int hashCode()返回该对象的哈希码值(内存地址的编号)-若equals()方法比较两个对象相等，则各自调用hashCode()结果必须相同-若equals()方法比较两个对象不相等，则各自调用hashCode()结果应该不同-若希望该方法与equals()结果保持一致，则需要重写该方法 String toString() 用于获取调用对象的字符串表示形式。 该方法默认返回：包名.类名@哈希码的十六进制。 若希望该方法返回更有意义的数据，则需要重写该方法。 当使用print/println打印引用时或+连接引用时，会自动调用该方法。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java常用类System","slug":"Java常用类System","date":"2020-06-08T09:54:29.000Z","updated":"2020-06-09T12:52:50.055Z","comments":true,"path":"2020/06/08/Java常用类System/","link":"","permalink":"http://fangpengcheng.com/2020/06/08/Java%E5%B8%B8%E7%94%A8%E7%B1%BBSystem/","excerpt":"","text":"System类是什么?","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java常用类Runtime","slug":"Java常用类Runtime","date":"2020-06-08T09:31:36.000Z","updated":"2020-06-08T09:48:10.312Z","comments":true,"path":"2020/06/08/Java常用类Runtime/","link":"","permalink":"http://fangpengcheng.com/2020/06/08/Java%E5%B8%B8%E7%94%A8%E7%B1%BBRuntime/","excerpt":"","text":"Runtime类是什么？每个java程序在运行时相当于启动了一个JVM进程，每个JVM进程都对应一个RunTime实例。此实例是JVM负责实例化的，所以我们不能实例化一个RunTime对象，只能通过getRuntime() 获取当前运行的Runtime对象的引用。一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去查看Java虚拟机的状态以及控制虚拟机的行为。 使用exec方法执行本地程序12345678Runtime runtime &#x3D;Runtime.getRuntime();try &#123; Process exec &#x3D; runtime.exec(&quot;notpead.ext&quot;); Thread.sleep(2000); exec.destroy();&#125; catch (IOException | InterruptedException e) &#123; e.printStackTrace();&#125; 产生大量垃圾123456789101112System.out.println(&quot;[1]返回 Java 虚拟机试图使用的最大内存量：&quot;+runtime.maxMemory());&#x2F;&#x2F;默认当前物理内存的4分之一System.out.println(&quot;[1]返回 Java 虚拟机中的内存总量：&quot;+runtime.totalMemory());&#x2F;&#x2F;默认为物理内存的六十四分之一System.out.println(&quot;[1]返回 Java 虚拟机中的空闲内存量:&quot;+runtime.freeMemory());String mag &#x3D; &quot;asdfg&quot;;for (int i &#x3D; 0; i &lt; 20; i++) &#123; mag +&#x3D;mag +i+&quot;\\n&quot;;&#125;System.out.println(&quot;[2]返回 Java 虚拟机试图使用的最大内存量：&quot;+runtime.maxMemory());&#x2F;&#x2F;默认当前物理内存的4分之一System.out.println(&quot;[2]返回 Java 虚拟机中的内存总量：&quot;+runtime.totalMemory());&#x2F;&#x2F;默认为物理内存的六十四分之一System.out.println(&quot;[2]返回 Java 虚拟机中的空闲内存量:&quot;+runtime.freeMemory()); 结果 123456[1]返回 Java 虚拟机试图使用的最大内存量：2835349504[1]返回 Java 虚拟机中的内存总量：192937984[1]返回 Java 虚拟机中的空闲内存量:190924680[2]返回 Java 虚拟机试图使用的最大内存量：2835349504[2]返回 Java 虚拟机中的内存总量：192937984[2]返回 Java 虚拟机中的空闲内存量:139910440 产生的异常循环次数太多的话，会让垃圾太多，产生内存溢出 1Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space 手动处理垃圾1runtime.gc(); 结果 123456[1]返回 Java 虚拟机试图使用的最大内存量：2835349504[1]返回 Java 虚拟机中的内存总量：192937984[1]返回 Java 虚拟机中的空闲内存量:190924680[2]返回 Java 虚拟机试图使用的最大内存量：2835349504[2]返回 Java 虚拟机中的内存总量：243269632[2]返回 Java 虚拟机中的空闲内存量:226072584","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java常用类AutoCloseable","slug":"Java常用类AutoCloseable","date":"2020-06-05T06:22:17.000Z","updated":"2020-06-08T08:46:57.014Z","comments":true,"path":"2020/06/05/Java常用类AutoCloseable/","link":"","permalink":"http://fangpengcheng.com/2020/06/05/Java%E5%B8%B8%E7%94%A8%E7%B1%BBAutoCloseable/","excerpt":"","text":"AutoCloseable 内容介绍自动关闭资源JDK1.7以后可用必须在try-catch中 代码用法123456789101112131415161718192021222324252627interface IMessage extends AutoCloseable&#123;&#x2F;&#x2F;直接继承接口 public void send(String msg);&#125;class NetMessage implements IMessage&#123; public NetMessage()&#123; System.out.println(&quot;【连接】连接远程服务器，创建消息的发送通道...&quot;); &#125; @Override public void send(String msg) &#123; System.out.println(&quot;【发送】&quot;+msg); &#125; public void close() &#123; System.out.println(&quot;【关闭】网络消息发送完毕，断开服务器连接...&quot;); &#125;&#125;public class textXx &#123; public static void main(String[] args)throws Exception &#123; try(NetMessage message &#x3D; new NetMessage())&#123;&#x2F;&#x2F;将对象存放到try中自动关闭 message.send(&quot;msg : www.baidu.com&quot;); &#125;catch (Exception e) &#123; e.getMessage(); &#125; &#125;&#125; 结果：123【连接】连接远程服务器，创建消息的发送通道...【发送】msg : www.baidu.com【关闭】网络消息发送完毕，断开服务器连接...","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java中isEmpty的用法","slug":"Java中isEmpty的用法","date":"2020-06-04T06:17:57.000Z","updated":"2020-06-08T07:15:23.387Z","comments":true,"path":"2020/06/04/Java中isEmpty的用法/","link":"","permalink":"http://fangpengcheng.com/2020/06/04/Java%E4%B8%ADisEmpty%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"判断对象内容是否为空一般是以长度为准。当且仅当 length() 为 0 时返回 true。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Oracle错误","slug":"Oracle错误","date":"2020-06-03T06:54:28.000Z","updated":"2020-06-11T03:28:04.021Z","comments":true,"path":"2020/06/03/Oracle错误/","link":"","permalink":"http://fangpengcheng.com/2020/06/03/Oracle%E9%94%99%E8%AF%AF/","excerpt":"","text":"ORA-00913:值过多12Insert into XX(?,?,?) values(?,?,?)上面是我们自己写的sql语句，我们要插入的值是3个。而数据库中对表XX的定义字段却只有两个，即XX（?,?）。所以我们传的参数的个数多出一个，这样数据库就会报“ORA-00913: 值过多”。 ORA-00911: 无效字符1添加了不能Oracle识别的字符，如:在sql末尾添加的‘;’ java.sql.SQLException: 无效的列索引123sql串的?号数目和提供的变量数目不一致。sql串里的?号书写不正确.sql串的?号用&#39;&#39;括了起来。","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://fangpengcheng.com/tags/Oracle/"}]},{"title":"虚拟机与本机的几种ip连接方式","slug":"虚拟机与本机的几种ip连接方式","date":"2020-06-03T01:21:22.000Z","updated":"2020-06-11T09:52:55.644Z","comments":true,"path":"2020/06/03/虚拟机与本机的几种ip连接方式/","link":"","permalink":"http://fangpengcheng.com/2020/06/03/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E6%9C%AC%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8Dip%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/","excerpt":"","text":"桥接模式(将虚拟机直接连接到外部网络)所谓的桥连接，就是说虚拟机的网络ip地址与我们的主机（母机）的ip在一个网段，加入我们windows机器的ip是192.168.172.11，那虚拟机的ip也将在92.168.172.XXX这个网络，这样虚拟机虽然可以直接上网也可以与主机互通但是可能会造成较多的网络ip冲突！ NAT模式(与虚拟机共享ip地址)仅主机模式 host-only模式注意 如果是笔记本电脑，虚拟机会连接无线网卡和有线网卡，桥接模式一定不要设置为自动","categories":[],"tags":[{"name":"Vmware","slug":"Vmware","permalink":"http://fangpengcheng.com/tags/Vmware/"}]},{"title":"Linux系统虚拟机安装","slug":"Linux系统虚拟机安装","date":"2020-06-02T09:39:05.000Z","updated":"2020-06-11T10:09:12.278Z","comments":true,"path":"2020/06/02/Linux系统虚拟机安装/","link":"","permalink":"http://fangpengcheng.com/2020/06/02/Linux%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/","excerpt":"","text":"下载centos7镜像连接地址: 1http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7.8.2003&#x2F;isos&#x2F;x86_64&#x2F;CentOS-7-x86_64-DVD-2003.iso vm虚拟机安装centos7新建一个虚拟机，选择对应版本 安装过程下一步即可,注意如果想要安装非桌面版，需要在安装中进行选择","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://fangpengcheng.com/tags/Linux/"}]},{"title":"递归删除目录下的所有文件","slug":"递归删除目录下的所有文件","date":"2020-06-02T09:28:23.000Z","updated":"2020-06-02T09:30:12.108Z","comments":true,"path":"2020/06/02/递归删除目录下的所有文件/","link":"","permalink":"http://fangpengcheng.com/2020/06/02/%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/","excerpt":"","text":"删除指定目录1234567891011121314public static boolean deleteDir(File dir) &#123; if (dir.isDirectory()) &#123; String[] children &#x3D; dir.list(); &#x2F;&#x2F; 递归删除目录中的子目录下 for (int i &#x3D; 0; i &lt; children.length; i++) &#123; boolean success &#x3D; deleteDir(new File(dir, children[i])); if (!success) &#123; return false; &#125; &#125; &#125; &#x2F;&#x2F; 目录此时为空，可以删除 return dir.delete();&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"URL的转码和解码","slug":"URL的转码和解码","date":"2020-06-02T09:20:20.000Z","updated":"2020-06-02T09:22:35.897Z","comments":true,"path":"2020/06/02/URL的转码和解码/","link":"","permalink":"http://fangpengcheng.com/2020/06/02/URL%E7%9A%84%E8%BD%AC%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/","excerpt":"","text":"转码12345678public static String encoder(String strTest) &#123; try &#123; strTest &#x3D; URLEncoder.encode(strTest, &quot;UTF-8&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return strTest;&#125; 解码12345678public static String decoder(String strTest) &#123; try &#123; strTest &#x3D; URLDecoder.decode(strTest, &quot;UTF-8&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return strTest;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Word、Excel、Ppt转换pdf","slug":"Word、Excel、Ppt转换pdf","date":"2020-06-02T09:04:11.000Z","updated":"2020-06-02T09:18:02.475Z","comments":true,"path":"2020/06/02/Word、Excel、Ppt转换pdf/","link":"","permalink":"http://fangpengcheng.com/2020/06/02/Word%E3%80%81Excel%E3%80%81Ppt%E8%BD%AC%E6%8D%A2pdf/","excerpt":"","text":"Word转换pdf同级目录添加一个license.xml，这个可以去除pdf上的过期水印 123456789101112131415&lt;License&gt; &lt;Data&gt; &lt;Products&gt; &lt;Product&gt;Aspose.Total for Java&lt;&#x2F;Product&gt; &lt;Product&gt;Aspose.Words for Java&lt;&#x2F;Product&gt; &lt;&#x2F;Products&gt; &lt;EditionType&gt;Enterprise&lt;&#x2F;EditionType&gt; &lt;SubscriptionExpiry&gt;20991231&lt;&#x2F;SubscriptionExpiry&gt; &lt;LicenseExpiry&gt;20991231&lt;&#x2F;LicenseExpiry&gt; &lt;SerialNumber&gt;23dcc79f-44ec-4a23-be3a-03c1632404e9&lt;&#x2F;SerialNumber&gt; &lt;&#x2F;Data&gt; &lt;Signature&gt; sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb&#x2F;2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE&#x2F;2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU&#x3D; &lt;&#x2F;Signature&gt;&lt;&#x2F;License&gt; 获取license.xml中的信息 12345678910111213141516171819202122 public static boolean getLicense() &#123; boolean result &#x3D; false; InputStream is &#x3D;null; try &#123;&#x2F;&#x2F; InputStream is &#x3D; WordToPdf.class.getClassLoader().getResourceAsStream(&quot;license.xml&quot;); &#x2F;&#x2F; license.xml应放在..\\WebRoot\\WEB-INF\\classes路径下 is &#x3D; WordToPdf.class.getResourceAsStream(&quot;license.xml&quot;); License aposeLic &#x3D; new License(); aposeLic.setLicense(is); result &#x3D; true; &#125; catch (Exception e) &#123; log.error(&quot;word转换成PDF getLicense():&quot;+e.getMessage()); &#125;finally &#123; if(is!&#x3D;null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; log.error(&quot;word转换成PDF is流关闭:&quot;+e.getMessage()); &#125; &#125; &#125; return result; &#125; 转换方法 1234567891011121314151617181920212223public static void docTopdf(String pathWord, String pathPdf) &#123; if (!getLicense()) &#123; &#x2F;&#x2F; 验证License 若不验证则转化出的pdf文档会有水印产生 return; &#125; FileOutputStream os &#x3D;null; try &#123; File file &#x3D; new File(pathPdf); &#x2F;&#x2F;新建一个空白pdf文档 Document doc &#x3D; new Document(pathWord); &#x2F;&#x2F; Address是将要被转化的word文档 os&#x3D; new FileOutputStream(file); doc.save(os, SaveFormat.PDF);&#x2F;&#x2F; 全面支持DOC, DOCX, OOXML, RTF HTML, OpenDocument, PDF, EPUB, XPS, SWF 相互转换 os.flush(); &#125; catch (Exception e) &#123; log.error(&quot;word转换成PDF:&quot;+e.getMessage()); &#125;finally &#123; if(os!&#x3D;null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; log.error(&quot;word转换成PDF os关闭:&quot;+e.getMessage()); &#125; &#125; &#125;&#125; 验证 12345public static void main(String[] args) &#123; String pathPdf &#x3D; &quot;D:\\\\2.pdf&quot;; String pathWord &#x3D; &quot;D:\\\\1.doc&quot;; WordToPdf.docTopdf(pathWord, pathPdf);&#125; Excel转换pdf同级目录添加一个license.xml，这个可以去除pdf上的过期水印 123456789101112131415&lt;License&gt; &lt;Data&gt; &lt;Products&gt; &lt;Product&gt;Aspose.Total for Java&lt;&#x2F;Product&gt; &lt;Product&gt;Aspose.Words for Java&lt;&#x2F;Product&gt; &lt;&#x2F;Products&gt; &lt;EditionType&gt;Enterprise&lt;&#x2F;EditionType&gt; &lt;SubscriptionExpiry&gt;20991231&lt;&#x2F;SubscriptionExpiry&gt; &lt;LicenseExpiry&gt;20991231&lt;&#x2F;LicenseExpiry&gt; &lt;SerialNumber&gt;23dcc79f-44ec-4a23-be3a-03c1632404e9&lt;&#x2F;SerialNumber&gt; &lt;&#x2F;Data&gt; &lt;Signature&gt; sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb&#x2F;2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE&#x2F;2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU&#x3D; &lt;&#x2F;Signature&gt;&lt;&#x2F;License&gt; 获取license.xml中的信息 12345678910111213141516171819202122 public static boolean getLicense() &#123; boolean result &#x3D; false; InputStream is &#x3D;null; try &#123;&#x2F;&#x2F; InputStream is &#x3D; WordToPdf.class.getClassLoader().getResourceAsStream(&quot;license.xml&quot;); &#x2F;&#x2F; license.xml应放在..\\WebRoot\\WEB-INF\\classes路径下 is &#x3D; WordToPdf.class.getResourceAsStream(&quot;license.xml&quot;); License aposeLic &#x3D; new License(); aposeLic.setLicense(is); result &#x3D; true; &#125; catch (Exception e) &#123; log.error(&quot;word转换成PDF getLicense():&quot;+e.getMessage()); &#125;finally &#123; if(is!&#x3D;null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; log.error(&quot;word转换成PDF is流关闭:&quot;+e.getMessage()); &#125; &#125; &#125; return result; &#125; 转换方法 1234567891011121314151617181920212223public static void excelTopdf(String pathexcel, String pathPdf) &#123; if (!getLicense()) &#123; &#x2F;&#x2F; 验证License 若不验证则转化出的pdf文档会有水印产生 return; &#125; FileOutputStream fileOS &#x3D; null; try &#123; File pdfFile &#x3D; new File(pathPdf);&#x2F;&#x2F; 输出路径 Workbook wb &#x3D; new Workbook(pathexcel);&#x2F;&#x2F; 原始excel路径 fileOS &#x3D; new FileOutputStream(pdfFile); wb.save(fileOS, SaveFormat.PDF); fileOS.flush(); &#125;catch (Exception e) &#123; log.error(&quot;将excel转换成PDF 验证License异常:&quot;+e.getMessage()); &#125;finally &#123; if(fileOS!&#x3D;null) &#123; try &#123; fileOS.close(); &#125; catch (IOException e) &#123; log.error(&quot;将excel转换成PDF,验证License流关闭异常:&quot;+e.getMessage()); &#125; &#125; &#125;&#125; 验证 12345public static void main(String[] args) &#123; String pathPdf &#x3D; &quot;D:\\\\1111.pdf&quot;; String pathexcel &#x3D; &quot;D:\\\\123.xlsx&quot;; excelTopdf(pathexcel, pathPdf);&#125; ppt转换pdf同级目录添加一个license.xml，这个可以去除pdf上的过期水印 12345678910111213&lt;License&gt; &lt;Data&gt; &lt;Products&gt; &lt;Product&gt;Aspose.Total for Java&lt;&#x2F;Product&gt; &lt;Product&gt;Aspose.Words for Java&lt;&#x2F;Product&gt; &lt;&#x2F;Products&gt; &lt;EditionType&gt;Enterprise&lt;&#x2F;EditionType&gt; &lt;SubscriptionExpiry&gt;20991231&lt;&#x2F;SubscriptionExpiry&gt; &lt;LicenseExpiry&gt;20991231&lt;&#x2F;LicenseExpiry&gt; &lt;SerialNumber&gt;8bfe198c-7f0c-4ef8-8ff0-acc3237bf0d7&lt;&#x2F;SerialNumber&gt; &lt;&#x2F;Data&gt; &lt;Signature&gt;sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb&#x2F;2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE&#x2F;2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU&#x3D;&lt;&#x2F;Signature&gt;&lt;&#x2F;License&gt; 1234567891011121314151617181920 boolean result &#x3D; false; InputStream license &#x3D; null; try &#123; license&#x3D;NscUtil.class.getResourceAsStream(&quot;Nsclicense.xml&quot;); License aposeLic &#x3D; new License(); aposeLic.setLicense(license); result &#x3D; true; &#125; catch (Exception e) &#123; log.error(&quot;ppt转换pdf getLicense():&quot;+e.getMessage()); &#125;finally &#123; if(license!&#x3D;null) &#123; try &#123; license.close(); &#125; catch (IOException e) &#123; log.error(&quot;ppt转换pdf getLicense() license流:&quot;+e.getMessage()); &#125; &#125;&#125; return result; &#125; 转换 12345678910111213141516171819202122232425262728 * * @param input输入 * @param ouput输出 *&#x2F; public static void pptToPdf(String input,String ouput) &#123; &#x2F;&#x2F; 验证License if (!getLicense()) &#123; return; &#125; FileOutputStream fileOS &#x3D; null; try &#123; File file &#x3D; new File(ouput);&#x2F;&#x2F; 输出pdf路径 Presentation pres &#x3D; new Presentation(input); fileOS&#x3D;new FileOutputStream(file); pres.save(fileOS, SaveFormat.Pdf); fileOS.flush(); &#125; catch (Exception e) &#123; log.error(&quot;ppt转换pdf:&quot;+e.getMessage()); &#125;finally &#123; if( fileOS!&#x3D;null) &#123; try &#123; fileOS.close(); &#125; catch (IOException e) &#123; log.error(&quot;ppt转换pdf fileOS流:&quot;+e.getMessage()); &#125; &#125;&#125; &#125; 验证 12345 public static void main(String[] args) &#123; String input&#x3D;&quot;D:&#x2F;20190913职业性有害因素的识别、评价与控制.ppt&quot;; String ouput&#x3D;&quot;D:&#x2F;test.pdf&quot;; pptToPdf(input,ouput);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"谷歌浏览器--nosandbox提示","slug":"谷歌浏览器-nosandbox提示","date":"2020-06-02T08:49:48.000Z","updated":"2020-06-02T08:52:23.304Z","comments":true,"path":"2020/06/02/谷歌浏览器-nosandbox提示/","link":"","permalink":"http://fangpengcheng.com/2020/06/02/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-nosandbox%E6%8F%90%E7%A4%BA/","excerpt":"","text":"谷歌出现 –no sandbox 提示无法去除12找到谷歌浏览器程序文件夹，复制”chrome.exe“，粘贴出现”chrome - 副本.exe“然后右键”chrome - 副本.exe“发送到桌面快捷方式。","categories":[],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://fangpengcheng.com/tags/chrome/"}]},{"title":"oa记录","slug":"oa记录","date":"2020-05-20T07:32:48.000Z","updated":"2020-06-12T04:01:35.529Z","comments":true,"path":"2020/05/20/oa记录/","link":"","permalink":"http://fangpengcheng.com/2020/05/20/oa%E8%AE%B0%E5%BD%95/","excerpt":"","text":"如何彻底卸载1.清除注册表 注册表搜索 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\SyncIntegrationClients 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\SEEYON2.清除用户上生成的文件.sii C:\\Users\\26385\\SiiFiles3.直接删除存放的文件夹 插入菜单栏1.方法一 设置关联系统，关联系统下设置工作区，然后修改主菜单 12update PRIV_MENU set RESOURCE_NAVURL&#x3D;null where id in (3503750930309923643)update PRIV_MENU set target&#x3D;null where id in (3503750930309923643) 2.方法二 直接插入sql 123456INSERT INTO PRIV_MENU VALUES (3733877095818150424, &#39;主菜单&#39;, &#39;vouchergenerate.png&#39;, Null, 996, NULL, &#39;666&#39;, &#39;0&#39;, &#39;1&#39;, NULL, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, to_date(&#39;2020-05-25 11:27:01&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;), NULL, to_date(&#39;2020-05-25 11:27:01&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;), NULL, 1, 1, 1, 2, 0);INSERT INTO PRIV_MENU VALUES (5312050049926647549, &#39;子菜单&#39;, &#39;vouchergenerate.png&#39;, &#39;mainfrm&#39;, 997, NULL, &#39;666001&#39;, &#39;0&#39;, &#39;2&#39;, NULL, 1, NULL, NULL, NULL, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;1&#39;, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 2, NULL, NULL, 1, &#39;&#x2F;ext&#x2F;NscTreeTJZH.do?method&#x3D;showDocTree&#39;, &#39;showDocTree&#39;, &#39;none&#39;, to_date(&#39;2020-05-25 11:27:01&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;), NULL, to_date(&#39;2020-05-25 11:27:01&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;), NULL, 1, 1, 1, 2, 3733877095818150424);&#96;&#96;&#96; 设置完成后，在管理员账户设置角色权限添加上菜单即可### 手动插入邮箱 org_member 表找到邮箱字段,更改邮箱ctp customize 表cvalue字段改成 true```","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://fangpengcheng.com/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"服务启动错误","slug":"服务启动错误","date":"2020-04-22T03:10:30.000Z","updated":"2020-04-22T03:15:11.584Z","comments":true,"path":"2020/04/22/服务启动错误/","link":"","permalink":"http://fangpengcheng.com/2020/04/22/%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF/","excerpt":"","text":"页面文件太小，无法完成操作123451.内存不足 提高内存2.上次服务没有关闭流，导致多次重启了java.exe 用任务管理器将Java(TM) Platform SE binary关闭 然后代码中流关闭","categories":[],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://fangpengcheng.com/tags/Tomcat/"}]},{"title":"List取交差集","slug":"List取交并差集","date":"2020-03-27T03:57:06.000Z","updated":"2020-06-02T08:45:15.508Z","comments":true,"path":"2020/03/27/List取交并差集/","link":"","permalink":"http://fangpengcheng.com/2020/03/27/List%E5%8F%96%E4%BA%A4%E5%B9%B6%E5%B7%AE%E9%9B%86/","excerpt":"","text":"两个List取交集 retainAll代码示例: 1234567List&lt;String&gt; a &#x3D; new ArrayList&lt;String&gt;();List&lt;String&gt; b &#x3D; new ArrayList&lt;String&gt;();a.add(&quot;1&quot;);a.add(&quot;2&quot;);b.add(&quot;1&quot;);a.retainAll(b);System.out.println(a); 结果: 1[1] 两个List取差集 removeAll1234567List&lt;String&gt; a &#x3D; new ArrayList&lt;String&gt;();List&lt;String&gt; b &#x3D; new ArrayList&lt;String&gt;();a.add(&quot;1&quot;);a.add(&quot;2&quot;);b.add(&quot;1&quot;);a.removeAll(b);System.out.println(a); 结果: 1[2]","categories":[{"name":"List","slug":"List","permalink":"http://fangpengcheng.com/categories/List/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java首字符大小写转换","slug":"Java首字符大小写转换","date":"2020-01-06T09:03:53.000Z","updated":"2020-01-06T09:36:16.696Z","comments":true,"path":"2020/01/06/Java首字符大小写转换/","link":"","permalink":"http://fangpengcheng.com/2020/01/06/Java%E9%A6%96%E5%AD%97%E7%AC%A6%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"首字母转大写 toUpperCase1234567public static String firstToUp(String str)&#123; if(&quot;&quot;.equals(str)) &#123; return str; &#125; String replaceFirst &#x3D; str.replaceFirst(str.substring(0,1), str.substring(0,1).toUpperCase()); return replaceFirst;&#125; 首字母转小写1234567public static String firstToDown(String str)&#123; if(&quot;&quot;.equals(str)) &#123; return str; &#125; String replaceFirst &#x3D; str.replaceFirst(str.substring(0,1), str.substring(0,1).toLowerCase()); return replaceFirst;&#125; 字母全部转大写1234567public static String alltoUp(String str) &#123;if(&quot;&quot;.equals(str)) &#123; return str;&#125;String replace &#x3D; str.toUpperCase();return replace;&#125; 字母全部转小写1234567public static String alltoDown(String str) &#123; if(&quot;&quot;.equals(str)) &#123; return str; &#125; String replace &#x3D; str.toLowerCase(); return replace;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java中基本数据类型和String类型的相互转换","slug":"Java中基本数据类型和String类型的相互转换","date":"2020-01-06T08:09:14.000Z","updated":"2020-06-08T07:15:51.209Z","comments":true,"path":"2020/01/06/Java中基本数据类型和String类型的相互转换/","link":"","permalink":"http://fangpengcheng.com/2020/01/06/Java%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8CString%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"基本类型转换成String方法：String.valueOf(); 例子: 12int a&#x3D;123;String s&#x3D;String.valueOf(a); &#x2F;&#x2F;s&#x3D;&quot;123&quot; String转基本数据类型方法：基本类型的包装类.parse基本类型(); 例子： 12String a&#x3D;&quot;123&quot;;int b&#x3D;Integer.parseInt(str); &#x2F;&#x2F;b&#x3D;123","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"BigDecimal类的简单用法","slug":"BigDecimal类的简单用法","date":"2020-01-06T06:58:58.000Z","updated":"2020-01-06T07:17:14.002Z","comments":true,"path":"2020/01/06/BigDecimal类的简单用法/","link":"","permalink":"http://fangpengcheng.com/2020/01/06/BigDecimal%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/","excerpt":"","text":"初始化使用String类型 12345BigDecimal num1 &#x3D; new BigDecimal(&quot;0.005&quot;);BigDecimal num2 &#x3D; new BigDecimal(&quot;1000000&quot;);BigDecimal num3 &#x3D; new BigDecimal(&quot;-1000000&quot;);BigDecimal num4 &#x3D; new BigDecimal(&quot;10&quot;);BigDecimal num5 &#x3D; new BigDecimal(&quot;3.335&quot;); 加/add()1num12.add(num22); 结果 11000000.005 减/subtract()1num32.subtract(num22) 结果 1-2000000 乘/multiply()1num1.multiply(num2) 结果 15000.000 除/divide()1num2.divide(num4) 结果 1100000 四舍五入保留两位小数12double doubleValue &#x3D; num5.setScale(2,RoundingMode.HALF_UP).doubleValue();System.out.println(doubleValue); 结果 13.34","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Map验证键值对是否存在","slug":"Map验证键值对是否存在","date":"2019-12-27T02:16:52.000Z","updated":"2019-12-27T04:05:32.504Z","comments":true,"path":"2019/12/27/Map验证键值对是否存在/","link":"","permalink":"http://fangpengcheng.com/2019/12/27/Map%E9%AA%8C%E8%AF%81%E9%94%AE%E5%80%BC%E5%AF%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/","excerpt":"","text":"示例代码1234Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();map.put(&quot;1&quot;, &quot;a&quot;);map.put(&quot;2&quot;, &quot;b&quot;);map.put(&quot;3&quot;, &quot;c&quot;); 判断键Key–containsKey1System.out.println(map.containsKey(&quot;1&quot;)); 判断value–containsValue1System.out.println(map.containsValue(&quot;b&quot;));","categories":[{"name":"Map","slug":"Map","permalink":"http://fangpengcheng.com/categories/Map/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Html的option标签","slug":"Html的option标签","date":"2019-12-25T09:49:38.000Z","updated":"2020-06-11T10:01:42.222Z","comments":true,"path":"2019/12/25/Html的option标签/","link":"","permalink":"http://fangpengcheng.com/2019/12/25/Html%E7%9A%84option%E6%A0%87%E7%AD%BE/","excerpt":"","text":"option标签示例1&lt;option&gt; 标签中的内容作为 &lt;select&gt; 或者&lt;datalist&gt; 一个元素使用。 select标签123456&lt;select&gt; &lt;option value&#x3D;&quot;第一个&quot;&gt;第一个&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;第二个&quot;&gt;第二个&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;第三个&quot;&gt;第三个&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;第四个&quot;&gt;第四个&lt;&#x2F;option&gt;&lt;&#x2F;select&gt; datalist标签1234567891011&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;get&quot;&gt; &lt;input list&#x3D;&quot;browsers&quot; name&#x3D;&quot;browser&quot;&gt; &lt;datalist id&#x3D;&quot;browsers&quot;&gt; &lt;option value&#x3D;&quot;Internet Explorer&quot;&gt; &lt;option value&#x3D;&quot;Firefox&quot;&gt; &lt;option value&#x3D;&quot;Chrome&quot;&gt; &lt;option value&#x3D;&quot;Opera&quot;&gt; &lt;option value&#x3D;&quot;Safari&quot;&gt; &lt;&#x2F;datalist&gt; &lt;input type&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;form&gt; option的属性disabled–禁用(不适用datalist标签)123456&lt;select&gt; &lt;option value&#x3D;&quot;volvo&quot; &gt;Volvo&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;saab&quot; disabled&gt;Saab&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;vw&quot;&gt;VW&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;audi&quot;&gt;Audi&lt;&#x2F;option&gt;&lt;&#x2F;select&gt; selected–首选项(不适用datalist标签)123456&lt;select&gt; &lt;option value&#x3D;&quot;第一个&quot;&gt;第一个&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;第二个&quot; &gt;第二个&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;第三个&quot; selected&gt;第三个&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;第四个&quot;&gt;第四个&lt;&#x2F;option&gt;&lt;&#x2F;select&gt; value–送到服务器的值123456789&lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;get&quot;&gt;&lt;select name&#x3D;&quot;cars&quot;&gt; &lt;option value&#x3D;&quot;volvo&quot;&gt;Volvo XC90&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;saab&quot;&gt;Saab 95&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;mercedes&quot;&gt;Mercedes SLK&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;audi&quot;&gt;Audi TT&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;&lt;&#x2F;form&gt;","categories":[{"name":"下拉列表","slug":"下拉列表","permalink":"http://fangpengcheng.com/categories/%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://fangpengcheng.com/tags/Html/"}]},{"title":"Java手动抛出异常","slug":"Java手动抛出异常","date":"2019-12-24T06:18:56.000Z","updated":"2019-12-24T06:55:48.183Z","comments":true,"path":"2019/12/24/Java手动抛出异常/","link":"","permalink":"http://fangpengcheng.com/2019/12/24/Java%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/","excerpt":"","text":"throw方法1234567if(a&#x3D;&#x3D;1) &#123; throw new RuntimeException(&quot;cuowu&quot;); &#125;else &#123; System.out.println(&quot;a不等于1&quot;);&#125;System.out.println(&quot;异常走不走这里呢&quot;); 结果12Exception in thread &quot;main&quot; java.lang.RuntimeException: 异常 at com.yc.sdyc.main(sdyc.java:8) 结论异常出现会终止程序运行。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Eclipse中Servers项目的功能","slug":"Eclipse中Servers项目的功能","date":"2019-12-24T01:36:48.000Z","updated":"2020-06-11T09:59:07.954Z","comments":true,"path":"2019/12/24/Eclipse中Servers项目的功能/","link":"","permalink":"http://fangpengcheng.com/2019/12/24/Eclipse%E4%B8%ADServers%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8A%9F%E8%83%BD/","excerpt":"","text":"Servers项目 功能服务器的配置文件,如果出现web容器问题,就可以修改此文件1.tomcat内存溢出2.jvm内存大小3.服务器启动web项目 删除了Servers项目后如何恢复1.file→new→others→server 2.服务器的配置","categories":[],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://fangpengcheng.com/tags/Eclipse/"}]},{"title":"Maven中新建一个servlet并实现跳转jsp","slug":"Maven中新建一个servlet并实现跳转jsp","date":"2019-12-22T10:03:44.000Z","updated":"2020-06-11T10:09:27.737Z","comments":true,"path":"2019/12/22/Maven中新建一个servlet并实现跳转jsp/","link":"","permalink":"http://fangpengcheng.com/2019/12/22/Maven%E4%B8%AD%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAservlet%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%BD%ACjsp/","excerpt":"","text":"pom.xml文件引入依赖包1234567891011121314 &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.servlet&#x2F;javax.servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;3.0.1&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.servlet&#x2F;jsp-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt; 新建一个servlet 注意web.xml中的配置12345678910&lt;servlet&gt; &lt;description&gt;&lt;&#x2F;description&gt; &lt;display-name&gt;StuendTestServlet&lt;&#x2F;display-name&gt; &lt;servlet-name&gt;StuendTestServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;com.end.test.StuendTestServlet&lt;&#x2F;servlet-class&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;StuendTestServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;StuendTestServlet&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 运行时出现的错误和纠正方法1A child container failed during start 这个错误原因是由于web.xml和servlet的重复配置url引起的,解决方法就是取出其中一个就可以了。建议去出servlet中的url.","categories":[],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://fangpengcheng.com/tags/Maven/"}]},{"title":"tomcat运行时找不到资源","slug":"tomcat运行时找不到资源","date":"2019-12-21T03:13:09.000Z","updated":"2020-06-11T10:11:33.254Z","comments":true,"path":"2019/12/21/tomcat运行时找不到资源/","link":"","permalink":"http://fangpengcheng.com/2019/12/21/tomcat%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E8%B5%84%E6%BA%90/","excerpt":"","text":"错误代码：Resource ‘/Servers2’ does not exist. 解决方案删除tomcat，重新加载","categories":[],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://fangpengcheng.com/tags/Tomcat/"}]},{"title":"本地搭建maven仓库","slug":"本地搭建maven仓库","date":"2019-12-19T12:59:16.000Z","updated":"2019-12-21T04:11:59.185Z","comments":true,"path":"2019/12/19/本地搭建maven仓库/","link":"","permalink":"http://fangpengcheng.com/2019/12/19/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAmaven%E4%BB%93%E5%BA%93/","excerpt":"","text":"","categories":[],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://fangpengcheng.com/tags/Maven/"}]},{"title":"java中PreparedStatement和Statement","slug":"java中PreparedStatement和Statement","date":"2019-12-18T02:17:07.000Z","updated":"2019-12-24T01:16:54.842Z","comments":true,"path":"2019/12/18/java中PreparedStatement和Statement/","link":"","permalink":"http://fangpengcheng.com/2019/12/18/java%E4%B8%ADPreparedStatement%E5%92%8CStatement/","excerpt":"","text":"PreparedStatement和Statement的区别就是PreparedStatement可以防止sql注入，Statement不能防止sql注入示例演示1https:&#x2F;&#x2F;www.cnblogs.com&#x2F;huangjinyong&#x2F;p&#x2F;9375952.html","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"sql中子查询的简单应用","slug":"sql中子查询的简单应用","date":"2019-12-17T15:49:15.000Z","updated":"2020-06-11T10:11:09.582Z","comments":true,"path":"2019/12/17/sql中子查询的简单应用/","link":"","permalink":"http://fangpengcheng.com/2019/12/17/sql%E4%B8%AD%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/","excerpt":"","text":"简单的子查询格式:select * from (select * from 表名) 例子1234567select id,姓名,部门,单位,岗位,职务级别,创建时间 from (select m.id,m.name as 姓名,u.name as 部门,n.name 单位,p.name as 岗位,L.name as 职务级别,m.CREATE_TIME as 创建时间,m.UPDATE_TIME as 更新时间 from org_member m left join ORG_UNIT u on m.ORG_DEPARTMENT_ID&#x3D;u.id left join ORG_UNIT n on m.ORG_ACCOUNT_ID &#x3D;n.id left join org_post p on m.ORG_POST_ID&#x3D;p.id left join ORG_LEVEL L on m.ORG_LEVEL_ID&#x3D;L.id where m.IS_ADMIN&#x3D;0 and m.name!&#x3D;&#39;系统登录前通用账号&#39;) where 姓名&#x3D;&#39;夏强&#39; 第一次查询结果查询出结果并且可以用别名让第二次查询结果使用 第二次查询结果子查询就是对第一次查询结果的临时表进行再次查询,并可以用第一次查询的结果的别名来充当字段名","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://fangpengcheng.com/tags/SQL/"}]},{"title":"sql中的查找时间范围","slug":"sql中的查找时间范围","date":"2019-12-17T15:48:51.000Z","updated":"2020-06-11T10:11:02.133Z","comments":true,"path":"2019/12/17/sql中的查找时间范围/","link":"","permalink":"http://fangpengcheng.com/2019/12/17/sql%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4/","excerpt":"","text":"注意开始时间结束时间，这里使用Oracle数据库演示1select * from ORG_UNIT where CREATE_TIME between to_date(&#39;2019-12-11&#39;,&#39;YYYY-MM-DD&#39;) and to_date(&#39;2019-12-13&#39;,&#39;YYYY-MM-DD&#39;) 查询结果","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://fangpengcheng.com/tags/SQL/"}]},{"title":"OA中注册bean","slug":"OA中注册bean","date":"2019-12-17T15:33:23.000Z","updated":"2020-06-11T10:10:19.581Z","comments":true,"path":"2019/12/17/OA中注册bean/","link":"","permalink":"http://fangpengcheng.com/2019/12/17/OA%E4%B8%AD%E6%B3%A8%E5%86%8Cbean/","excerpt":"","text":"配置环境的时候尽量复制name要首字母小写 引用时要注意名称的正确类名+bean的name。使用alt+shilt+s，增加get、set方法。","categories":[],"tags":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"}]},{"title":"Oracle日期格式","slug":"Oracle日期格式","date":"2019-12-17T15:33:06.000Z","updated":"2020-06-11T10:10:55.064Z","comments":true,"path":"2019/12/17/Oracle日期格式/","link":"","permalink":"http://fangpengcheng.com/2019/12/17/Oracle%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"使用to_date方法进行时间日期格式的转换to_date(‘要插入的日期时间’,’日期时间格式’) 示例1select * from ORG_UNIT where CREATE_TIME between to_date(&#39;2019-12-11&#39;,&#39;YYYY-MM-DD&#39;) and to_date(&#39;2019-12-13&#39;,&#39;YYYY-MM-DD&#39;) 结果","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://fangpengcheng.com/tags/Oracle/"}]},{"title":"OA中连接ajax的方式","slug":"OA中连接ajax的方式","date":"2019-12-16T02:40:49.000Z","updated":"2020-06-11T10:10:12.885Z","comments":true,"path":"2019/12/16/OA中连接ajax的方式/","link":"","permalink":"http://fangpengcheng.com/2019/12/16/OA%E4%B8%AD%E8%BF%9E%E6%8E%A5ajax%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"配置环境的时候尽量复制目录 jsp配置的两种方式 xml配置 bean的xml配置 manager中方法","categories":[],"tags":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"}]},{"title":"Linux系统设备没有空间","slug":"Linux系统设备没有空间","date":"2019-12-13T08:44:38.000Z","updated":"2019-12-26T03:05:39.440Z","comments":true,"path":"2019/12/13/Linux系统设备没有空间/","link":"","permalink":"http://fangpengcheng.com/2019/12/13/Linux%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E6%B2%A1%E6%9C%89%E7%A9%BA%E9%97%B4/","excerpt":"","text":"在linux中设备空间有两个条件决定的：硬盘容量 和 inode硬盘与inode其中一项超额就会造成 设备上没有空间 异常错误，当出现这类错误基本上可以从这两个方面去考虑，一般使用命令 df：df –help 判断硬盘满：（发现有占用率达100% 就可以断定该分区满了）1df -h 判断inode满：（发现有占用率达100%就可以断定该分区碎片文件超多）1df -ia 当不知道有哪些目录中存在大量碎片文件时，可通过命令：（查找出超过10M的目录，再行处理）1find &#x2F; -type d -size +10M","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://fangpengcheng.com/tags/Linux/"}]},{"title":"StringBuffer的删除功能","slug":"StringBuffer的删除功能","date":"2019-12-13T06:59:50.000Z","updated":"2019-12-21T04:25:10.195Z","comments":true,"path":"2019/12/13/StringBuffer的删除功能/","link":"","permalink":"http://fangpengcheng.com/2019/12/13/StringBuffer%E7%9A%84%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD/","excerpt":"","text":"12345678910111213141516171819StringBuffer sb &#x3D; new StringBuffer();&#x2F;&#x2F;添加功能sb.append(&quot;hello&quot;).append(&quot;world&quot;).append(&quot;java&quot;);System.out.println(sb);&#x2F;&#x2F;public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身&#x2F;&#x2F;需求：我要删除指定的第二个字符，怎么办？sb.deleteCharAt(1);System.out.println(&quot;删除第二个字符:&quot;+sb);&#x2F;&#x2F;需求：我要删除第一个l这个字符？sb.deleteCharAt(1);System.out.println(&quot;删除第一个l:&quot;+sb);&#x2F;&#x2F;public StringBuffer delete(int start,int end):删除从指定位置开始到指定位置结束的内容，并返回本身&#x2F;&#x2F;需求：我要删除world这个字符&#x2F;&#x2F;包左不包右sb.delete(3, 8);System.out.println(&quot;删除world:&quot;+sb);&#x2F;&#x2F;需求：我要删除所有的数据sb.delete(0, sb.length());System.out.println(&quot;删除所有的数据:&quot;+sb); 结果：12345helloworldjava删除第二个字符:hlloworldjava删除第一个l:hloworldjava删除world:hlojava删除所有的数据:","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"div增加滚动条","slug":"div增加滚动条","date":"2019-12-13T06:25:24.000Z","updated":"2020-06-11T09:57:48.554Z","comments":true,"path":"2019/12/13/div增加滚动条/","link":"","permalink":"http://fangpengcheng.com/2019/12/13/div%E5%A2%9E%E5%8A%A0%E6%BB%9A%E5%8A%A8%E6%9D%A1/","excerpt":"","text":"示例 class样式 overflow:auto123456&lt;div style&#x3D;&quot;height:300px;width:70px;overflow:auto;background:#EEEEEE;&quot;&gt;菜鸟教程 -- 学的不仅是技术，更是梦想！！！菜鸟教程 -- 学的不仅是技术，更是梦想！！！菜鸟教程 -- 学的不仅是技术，更是梦想！！！菜鸟教程 -- 学的不仅是技术，更是梦想！！！&lt;&#x2F;div&gt; overflow 设置为 scroll 可以让滚动条一直存在设置水平滚动条1&lt;div style&#x3D;&quot;width:100px;overflow-x:auto&quot;&gt;&lt;&#x2F;div&gt; 设置垂直滚动条1&lt;div style&#x3D;&quot;width:100px;overflow-y:auto&quot;&gt;&lt;&#x2F;div&gt;","categories":[],"tags":[{"name":"Html","slug":"Html","permalink":"http://fangpengcheng.com/tags/Html/"}]},{"title":"sql插入00001","slug":"sql插入00001","date":"2019-12-11T07:42:34.000Z","updated":"2019-12-21T04:24:31.225Z","comments":true,"path":"2019/12/11/sql插入00001/","link":"","permalink":"http://fangpengcheng.com/2019/12/11/sql%E6%8F%92%E5%85%A500001/","excerpt":"","text":"1.数据库字段不能是number。2.把赋值的数字用单引号引起来示例1update org_unit set path&#x3D;&#39;00000003&#39; where id&#x3D;-5712375927319737666","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://fangpengcheng.com/tags/SQL/"}]},{"title":"Java静态方法为什么不用实例化","slug":"Java静态方法为什么不用实例化","date":"2019-12-11T07:40:26.000Z","updated":"2019-12-21T04:18:44.697Z","comments":true,"path":"2019/12/11/Java静态方法为什么不用实例化/","link":"","permalink":"http://fangpengcheng.com/2019/12/11/Java%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%8C%96/","excerpt":"","text":"静态方法关键字static 静态方法加载时间静态方法在class文件被加载时就会分配内存，而非静态的方法在程序运行过程中实例化后才会存在。 静态方法的调用静态方法可以用类名来调用，不用实例化，也可以用对象名来调用;而非静态方法只能在类实例化之后用对象名来调用; 示例12345678910111213141516public class test07 &#123; public static void main(String[] args) &#123; test07 n &#x3D; new test07(); n.test1(); test2(); &#125; public static void test2() &#123; String name &#x3D; &quot;静态方法&quot;; System.out.println(name); &#125; public void test1() &#123; String name&#x3D;&quot;非静态方法&quot;; System.out.println(name); &#125;&#125; 结果12非静态方法静态方法","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java创建对象的几种方式","slug":"Java创建对象的几种方式","date":"2019-12-10T12:44:37.000Z","updated":"2020-06-11T10:03:51.401Z","comments":true,"path":"2019/12/10/Java创建对象的几种方式/","link":"","permalink":"http://fangpengcheng.com/2019/12/10/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"new对象1234567891011public class classDemo &#123; public static void main(String[] args) &#123; classDemo demo &#x3D; new classDemo(); String name2 &#x3D; demo.name(); System.out.println(name2); &#125; public String name() &#123; return &quot;new对象创建成功&quot;; &#125;&#125; 结果new对象创建成功 class创建对象 代码book.java 12345678package com.bean;import java.util.List;public class book &#123; public static String name() &#123; return &quot;反射创建对象成功&quot;; &#125;&#125; classDemo.java 123456789101112131415161718192021package com.test;import com.bean.book;public class classDemo &#123; public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; forName &#x3D; Class.forName(&quot;com.bean.book&quot;); Object newInstance &#x3D; forName.newInstance(); book ok&#x3D; (book)newInstance; String name &#x3D; book.name(); System.out.println(name); &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; public String name() &#123; return &quot;new对象创建成功&quot;; &#125;&#125; 结果反射创建对象成功","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java匿名对象","slug":"Java匿名对象","date":"2019-12-10T12:37:25.000Z","updated":"2019-12-21T04:18:59.078Z","comments":true,"path":"2019/12/10/Java匿名对象/","link":"","permalink":"http://fangpengcheng.com/2019/12/10/Java%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"匿名对象的概念:匿名对象是值在创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量创建一个普通对象1person p &#x3D; new person(); 创建一个匿名对象1new person(); 匿名对象的特点:1.创建的匿名对象直接使用，没用变量名2.匿名对象在没有引用其他变量时，只能使用一次。3.匿名对象可以作为方法接收的参数、方法返回值使用。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"sql计数查询","slug":"sql计数查询","date":"2019-12-10T12:32:24.000Z","updated":"2019-12-21T04:24:37.204Z","comments":true,"path":"2019/12/10/sql计数查询/","link":"","permalink":"http://fangpengcheng.com/2019/12/10/sql%E8%AE%A1%E6%95%B0%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"计数count()1select count(*) from stuend","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://fangpengcheng.com/tags/SQL/"}]},{"title":"sql模糊查询","slug":"sql模糊查询","date":"2019-12-10T12:15:14.000Z","updated":"2019-12-21T04:24:40.915Z","comments":true,"path":"2019/12/10/sql模糊查询/","link":"","permalink":"http://fangpengcheng.com/2019/12/10/sql%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"模糊查询使用方法SQL LIKE子句中使用百分号 %字符来表示任意字符,如果没有使用百分号 %, LIKE子句与等号 = 的效果是一样的。 开头带有a的字段1select * from stuend where name like &#39;a%&#39; 中间带有b的字段1select * from stuend where name like &#39;%b%&#39; 末尾带有c的字段1select * from stuend where name like &#39;%c&#39;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://fangpengcheng.com/tags/SQL/"}]},{"title":"sql中规定字段长度查询","slug":"sql中规定字段长度查询","date":"2019-12-10T11:38:16.000Z","updated":"2020-06-11T10:11:05.524Z","comments":true,"path":"2019/12/10/sql中规定字段长度查询/","link":"","permalink":"http://fangpengcheng.com/2019/12/10/sql%E4%B8%AD%E8%A7%84%E5%AE%9A%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"length的使用length写在返回值的位置1select length(name) from stuend 查询结果 length写在查询的条件里1select * from stuend where length(name)&#x3D;3 查询结果","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://fangpengcheng.com/tags/SQL/"}]},{"title":"OA关联系统域名和ip","slug":"OA关联系统域名和ip","date":"2019-12-05T09:14:47.000Z","updated":"2019-12-21T04:32:02.966Z","comments":true,"path":"2019/12/05/OA关联系统域名和ip/","link":"","permalink":"http://fangpengcheng.com/2019/12/05/OA%E5%85%B3%E8%81%94%E7%B3%BB%E7%BB%9F%E5%9F%9F%E5%90%8D%E5%92%8Cip/","excerpt":"","text":"错误出现在北汽蓝谷7.0sp2单点登录第三方的时候配置正确的情况下，关联系统无法跳转controller，并提示被迫下线无法连接服务器.ip登录可以直接单点成功。 原因客户使用了域名登录并非ip登录 解决方案将关联系统的ip地址更改为域名地址","categories":[],"tags":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"}]},{"title":"OA节点事件配置","slug":"OA节点事件配置","date":"2019-12-04T07:16:15.000Z","updated":"2020-06-11T10:10:04.405Z","comments":true,"path":"2019/12/04/OA节点事件配置/","link":"","permalink":"http://fangpengcheng.com/2019/12/04/OA%E8%8A%82%E7%82%B9%E4%BA%8B%E4%BB%B6%E9%85%8D%E7%BD%AE/","excerpt":"","text":"创建表单创建一个表单，表单赋予模板编号 创建一个应用业务流程集成配置进入system账户-cip平台-集成业务","categories":[{"name":"节点事件","slug":"节点事件","permalink":"http://fangpengcheng.com/categories/%E8%8A%82%E7%82%B9%E4%BA%8B%E4%BB%B6/"}],"tags":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"}]},{"title":"JDBC连接池","slug":"JDBC连接池","date":"2019-11-27T07:43:04.000Z","updated":"2020-06-11T10:11:54.597Z","comments":true,"path":"2019/11/27/JDBC连接池/","link":"","permalink":"http://fangpengcheng.com/2019/11/27/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"","text":"什么是JDBC连接池存放多个连接的集合 连接池的目的解决建立数据库连接耗费资源和时间很多的问题,提高性能 DBCP连接池12","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://fangpengcheng.com/categories/JDBC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"mysql遇到1175报错","slug":"mysql遇到1175报错","date":"2019-11-26T13:00:36.000Z","updated":"2019-12-21T04:23:31.880Z","comments":true,"path":"2019/11/26/mysql遇到1175报错/","link":"","permalink":"http://fangpengcheng.com/2019/11/26/mysql%E9%81%87%E5%88%B01175%E6%8A%A5%E9%94%99/","excerpt":"","text":"在进行更新/删除操作的时候提示报错为1175解决方法 1SET SQL_SAFE_UPDATES &#x3D; 0; 运行后在进行更删操作","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://fangpengcheng.com/tags/Mysql/"}]},{"title":"JDBC增删改查","slug":"JDBC增删改查","date":"2019-11-26T12:13:33.000Z","updated":"2019-12-21T04:21:13.407Z","comments":true,"path":"2019/11/26/JDBC增删改查/","link":"","permalink":"http://fangpengcheng.com/2019/11/26/JDBC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","excerpt":"","text":"插入12345678910111213141516public static void insert() &#123; Connection connection &#x3D; JDBCUilt.getConnection(); ResultSet executeQuery &#x3D;null; Statement sts &#x3D;null; try &#123; sts&#x3D; connection.createStatement(); String sql &#x3D; &quot;insert into test values(3,&#39;gg&#39;)&quot;; int executeUpdate &#x3D; sts.executeUpdate(sql); System.out.println(executeUpdate); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUilt.clossAll(connection, sts, executeQuery); &#125;&#125; 加入预处理对象123456789101112131415161718public static void insert(int id,String name) &#123; Connection connection &#x3D; JDBCUilt.getConnection(); ResultSet executeQuery &#x3D;null; PreparedStatement psmt &#x3D; null; try &#123; String sql &#x3D; &quot;insert into test values(?,?)&quot;; psmt &#x3D; connection.prepareStatement(sql); psmt.setInt(1, id); psmt.setString(2, name); int executeUpdate &#x3D; psmt.executeUpdate(); System.out.println(executeUpdate); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUilt.clossAll(connection, psmt, executeQuery); &#125;&#125; 删除12345678910111213141516171819public static void delete() &#123; Connection connection &#x3D; JDBCUilt.getConnection(); ResultSet executeQuery &#x3D;null; Statement sts &#x3D;null; try &#123; sts&#x3D; connection.createStatement(); String sql &#x3D; &quot;delete from test where id&#x3D;1;&quot;; executeQuery&#x3D; sts.executeQuery(sql); while(executeQuery.next()) &#123; Object object &#x3D; executeQuery.getObject(1); System.out.println(object); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUilt.clossAll(connection, sts, executeQuery); &#125;&#125; 加入预处理对象12345678910111213141516public static void delete(int id) &#123; Connection connection &#x3D; JDBCUilt.getConnection(); ResultSet executeQuery &#x3D;null; PreparedStatement psmt&#x3D;null; try &#123; String sql &#x3D; &quot;delete from test where id&#x3D;?&quot;; psmt&#x3D; connection.prepareStatement(sql); psmt.setInt(1, id); int executeUpdate &#x3D; psmt.executeUpdate(); System.out.println(executeUpdate); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUilt.clossAll(connection, psmt, executeQuery); &#125;&#125; 修改123456789101112131415public static void update() &#123; Connection connection &#x3D; JDBCUilt.getConnection(); ResultSet executeQuery &#x3D;null; Statement sts &#x3D;null; try &#123; sts&#x3D; connection.createStatement(); String sql &#x3D; &quot;update test set name&#x3D;&#39;bbb&#39; where id&#x3D; 3 &quot;; int executeUpdate &#x3D; sts.executeUpdate(sql); System.out.println(executeUpdate); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUilt.clossAll(connection, sts, executeQuery); &#125;&#125; 加入预处理对象1234567891011121314151617public static void update(String name,int id) &#123; Connection connection &#x3D; JDBCUilt.getConnection(); ResultSet executeQuery &#x3D;null; PreparedStatement psmt&#x3D;null; try &#123; String sql &#x3D; &quot;update test set name &#x3D; ? where id &#x3D; ?&quot;; psmt &#x3D; connection.prepareStatement(sql); psmt.setString(1, name); psmt.setInt(2, id); int executeUpdate &#x3D; psmt.executeUpdate(); System.out.println(executeUpdate); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUilt.clossAll(connection, psmt, executeQuery); &#125;&#125; 查询123456789101112131415161718public static void query() &#123; Connection connection &#x3D; JDBCUilt.getConnection(); ResultSet executeQuery &#x3D;null; Statement sts &#x3D;null; try &#123; sts&#x3D; connection.createStatement(); String sql &#x3D; &quot;select name from test&quot;; executeQuery&#x3D; sts.executeQuery(sql); while(executeQuery.next()) &#123; Object object &#x3D; executeQuery.getObject(1); System.out.println(object); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUilt.clossAll(connection, sts, executeQuery); &#125;&#125; 加入与处理对象12345678910111213141516171819public static void query(int id) &#123; Connection connection &#x3D; JDBCUilt.getConnection(); ResultSet executeQuery &#x3D;null; PreparedStatement psmt &#x3D; null; try &#123; String sql &#x3D; &quot;select name from test where id&#x3D;?&quot;; psmt &#x3D; connection.prepareStatement(sql); psmt.setInt(1, id); executeQuery &#x3D; psmt.executeQuery(); while(executeQuery.next()) &#123; Object object &#x3D; executeQuery.getObject(1); System.out.println(object); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUilt.clossAll(connection, psmt, executeQuery); &#125;&#125; 连接工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package testfile;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBCUilt &#123; &#x2F;&#x2F;主要是获取数据库连接 private static String driverName&#x3D; &quot;com.mysql.jdbc.Driver&quot;; private static String url &#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useSSL&#x3D;false&quot;; private static String userName&#x3D;&quot;root&quot;; private static String password&#x3D;&quot;fang123&quot;; public static Connection getConnection() &#123; Connection conn &#x3D; null ; try &#123; Class.forName(driverName); conn&#x3D; DriverManager.getConnection(url, userName, password); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; &#x2F;&#x2F;关闭所有资源 public static void clossAll(Connection conn,Statement sts,ResultSet count) &#123; if(conn!&#x3D;null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(sts!&#x3D;null) &#123; try &#123; sts.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(count!&#x3D;null) &#123; try &#123; count.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://fangpengcheng.com/categories/JDBC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"win10常用快捷键","slug":"win10常用快捷键","date":"2019-11-25T03:56:10.000Z","updated":"2020-06-02T08:58:46.342Z","comments":true,"path":"2019/11/25/win10常用快捷键/","link":"","permalink":"http://fangpengcheng.com/2019/11/25/win10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"复制ctrl+c 粘贴ctrl+v 剪切ctrl+x 桌面window+d 应用切换ALT+Tab 桌面切换Ctrl+window+方向键 截图键1.window+Shift+S2.prtScr 中英文输入法切换Alt+Shift 大小写切换CapsLock 删除delete 任务管理器Ctrl+Alt+delete 开关数字键NumLock 选中shift+方向键 锁屏window+L 打开我的电脑window+e 录屏录音window+g","categories":[],"tags":[{"name":"window","slug":"window","permalink":"http://fangpengcheng.com/tags/window/"}]},{"title":"OA接口调用","slug":"OA接口调用","date":"2019-11-22T08:16:29.000Z","updated":"2019-12-21T04:32:09.697Z","comments":true,"path":"2019/11/22/OA接口调用/","link":"","permalink":"http://fangpengcheng.com/2019/11/22/OA%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/","excerpt":"","text":"核心代码123456789101112131415161718192021222324URL url &#x3D; new URL(BMPUrl);HttpURLConnection connection &#x3D; (HttpURLConnection)url.openConnection();connection.setDoInput(true);connection.setDoOutput(true);connection.setUseCaches(false);connection.setInstanceFollowRedirects(true);connection.setRequestMethod(&quot;POST&quot;);connection.setRequestProperty(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;utf-8&quot;);connection.connect();InputStream is &#x3D; null;if (connection.getResponseCode() &#x3D;&#x3D; 200) &#123;is &#x3D; connection.getInputStream();&#125; else &#123;is &#x3D; connection.getErrorStream();System.out.println(&quot;请求出错，错误编号：&quot; + connection.getResponseCode());&#125;BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(is, &quot;utf-8&quot;));String temp &#x3D; null;StringBuffer sb &#x3D; new StringBuffer();while ((temp &#x3D; br.readLine()) !&#x3D; null) &#123;sb.append(temp);&#125;result &#x3D; sb.toString();","categories":[],"tags":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"}]},{"title":"JDBC和驱动","slug":"JDBC和驱动","date":"2019-11-21T12:41:59.000Z","updated":"2020-06-11T10:07:13.320Z","comments":true,"path":"2019/11/21/JDBC和驱动/","link":"","permalink":"http://fangpengcheng.com/2019/11/21/JDBC%E5%92%8C%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"什么是JDBCjdbc是一种用于执行sql语句的java API，JDBC是java连接数据库的一种规范，可以为不同的关系型数据库提供统一访问，它由一组用Java语言编写的接口(大部分)和类组成。 什么是数据库驱动JDBC需要连接驱动，驱动是两个设备进行数据通信的格式，数据格式由厂商提供驱动，通过软件达到与数据库通信。 mysql的驱动是mysql-connector-java-5.1.39-bin.jarOracle的驱动是ojdbc5.jar JDBC的4个核心对象1.注册驱动:使用DriverManger来注册 2.获取和数据库的连接对象: 是Connection接口的实现类对象 3.获取SQL语句的执行者对象: 是Statement接口的实现类对象 4.结果集对象:是ResultSet接口的实现类对象 注册驱动DriverManager.registerDriver(new com.mysql.jdbc.Driver());不建议使用 原因有2个： 1.导致驱动被注册2次。 2.强烈依赖数据库的驱动jar 解决办法：Class.forName(“com.mysql.jdbc.Driver”);//mysql的驱动 获得连接url:mysql: jdbc:mysql://localhost:3306/day04或者jdbc:mysql:///day14（默认连接本机）userName:数据库账户password:数据库密码static Connection getConnection(String url, String userName, String password) 试图建立到给定数据库 URL 的连接。 mysql： jdbc:mysql://localhost:3306/day06 协议 子协议 IP : 端口号 数据库 oracle数据库: jdbc:oracle:thin:@localhost:1521:sid 执行sql语句123String sql &#x3D; &quot;某SQL语句&quot;;Statement stmt &#x3D; con.createStatement();stmt.execute(); int executeUpdate(String sql); –执行insert update delete语句.增删改ResultSet executeQuery(String sql); –执行select语句.查询boolean execute(String sql); –仅当执行select并且有结果时才返回true，执行其他的语句返回false.判断是否执行成功 处理结果集（注意：执行insert update delete语句.不需要处理结果集）1234567&#x2F;&#x2F;查询结果处理ResultSet count &#x3D; sts.executeQuery(sql);while (count.next()) &#123; &#x2F;&#x2F;用object可以接收任意的数据类型。 Object object &#x3D; count.getObject(1); System.out.println(object);&#125; 关闭资源12sts.close();conn.close(); 导入包12345import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://fangpengcheng.com/categories/JDBC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Eclipse常用快捷键","slug":"Eclipse常用快捷键","date":"2019-11-21T01:50:46.000Z","updated":"2019-12-24T01:49:45.722Z","comments":true,"path":"2019/11/21/Eclipse常用快捷键/","link":"","permalink":"http://fangpengcheng.com/2019/11/21/Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"快速导入包ctrl+shift+o 代码对齐ctrl+shift+f 代码提示ctrl+alt+/","categories":[],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://fangpengcheng.com/tags/Eclipse/"}]},{"title":"Http响应代码","slug":"Http响应代码","date":"2019-11-20T12:51:36.000Z","updated":"2020-06-11T06:21:54.892Z","comments":true,"path":"2019/11/20/Http响应代码/","link":"","permalink":"http://fangpengcheng.com/2019/11/20/Http%E5%93%8D%E5%BA%94%E4%BB%A3%E7%A0%81/","excerpt":"","text":"HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。五大分类信息响应(100–199)100 迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。101 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。通知客户端采用不同的协议完成这个请求102 此代码表示服务器已收到并正在处理该请求，但没有响应可用。 成功响应(200–299)200 ok请求成功 重定向(300–399)302 请求的资源现在临时从不同的 URI 响应请求，由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。 客户端错误(400–499)400 表示客户端的请求语法错误403 表示服务器接收到了请求，但是拒绝对其请求进行处理404 请求失败，请求所希望得到的资源未被在服务器上发现。409 请求资源与当前状态冲突 服务器错误 (500–599)500 服务器内部发生了错误505 表示服务器不支持或拒绝支持请求行中给出的HTTP版本","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://fangpengcheng.com/tags/HTTP/"}]},{"title":"Java连接Mysql数据库","slug":"Java连接Mysql数据库","date":"2019-11-20T09:45:00.000Z","updated":"2019-12-21T04:18:50.676Z","comments":true,"path":"2019/11/20/Java连接Mysql数据库/","link":"","permalink":"http://fangpengcheng.com/2019/11/20/Java%E8%BF%9E%E6%8E%A5Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"main方法里运行导入mysql-connector-java-5.1.39-bin.jar 代码123456789101112131415&#x2F;&#x2F;mysql驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;&quot;jdbc：数据库类型&#x2F;&#x2F;地址:端口&#x2F;数据库名?useSSL&#x3D;false&quot;,&quot;用户名&quot;,&quot;密码&quot;conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useSSL&#x3D;false&quot;, &quot;root&quot;, &quot;fang123&quot;);System.out.println(conn);&#x2F;&#x2F; 3.构建SQL语句String sql &#x3D; &quot;insert into test values(1,&#39;abc&#39;)&quot;;&#x2F;&#x2F; 4.执行SQL语句Statement sts &#x3D; conn.createStatement(); &#x2F;&#x2F; 返回的结果是影响的行数int count &#x3D; sts.executeUpdate(sql);System.out.println(&quot;影响的行数：&quot;+count); &#x2F;&#x2F; 5.关闭资源sts.close();conn.close(); 输出结果12com.mysql.jdbc.JDBC4Connection@2d8e6db6影响的行数：1 出现异常Wed Nov 20 17:51:57 CST 2019 WARN: Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 解决方案：conn = DriverManager.getConnection(“jdbc:mysql://localhost:3306/test?useSSL=false”, “root”, “fang123”);url中添加?useSSL=false","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"},{"name":"Mysql","slug":"Mysql","permalink":"http://fangpengcheng.com/tags/Mysql/"}]},{"title":"Java包装类","slug":"Java包装类","date":"2019-11-20T07:50:23.000Z","updated":"2020-06-16T12:48:47.237Z","comments":true,"path":"2019/11/20/Java包装类/","link":"","permalink":"http://fangpengcheng.com/2019/11/20/Java%E5%8C%85%E8%A3%85%E7%B1%BB/","excerpt":"","text":"什么是包装类?java面向对象但并不是纯面向对象的语言，java的基本数据类型就不是面向对象的，但是在实际使用中我们经常需要将其转换成对象使用,将变量进行对象化处理和包装。 基本数据类型与包装类的对比int =&gt; Integerchar =&gt;Character Integer类介绍java.lang.Integer类是int类型包装类，该类由final修饰注：final修饰 表示不能被继承 方法Integer(int value) –根据参数指定的整数来构造对象 Integer(String s) –根据参数指定的字符串来构造对象 该类重写了equals()方法、hashCode()的方法int intValue() -用于获取调用对象包装的整数数据并返回static Integer valueOf(int i) –根据参数指定的整数得到Integer类型static int parseInt(String s) -用于将String类型转换为int类型 类型转换123456789&#x2F;&#x2F;实现从Integer类型和int类型转换int num &#x3D; i1.intValue();System.out.println(num);&#x2F;&#x2F;实现从int类型导Integer类型的转换 Integer valueOf &#x3D; Integer.valueOf(num);System.out.println(valueOf);&#x2F;&#x2F;实现从String类型导int类型的转换 int parseInt &#x3D; Integer.parseInt(&quot;12345&quot;);System.out.println(&quot;parseInt&#x3D;&quot;+parseInt); 装箱和拆箱装箱：int类型想Integer类型转换拆箱：Integer类型想int类型转换从jdk1.5开始支持自动装箱和自动拆箱 自动装箱池为了提高效率在Integer类的内部提前将-128到127之间的所有整数装箱完毕并放入自动装箱池中，若程序中出现该范围的整数则直接从池中取出Cache to support the object identity semantics of autoboxing for values between -128 and 127 (inclusive) as required by JLS.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"MySQLWorkbench8.0CE目录汉化","slug":"MySQLWorkbench8-0CE目录汉化","date":"2019-11-20T07:19:33.000Z","updated":"2020-06-11T10:09:39.748Z","comments":true,"path":"2019/11/20/MySQLWorkbench8-0CE目录汉化/","link":"","permalink":"http://fangpengcheng.com/2019/11/20/MySQLWorkbench8-0CE%E7%9B%AE%E5%BD%95%E6%B1%89%E5%8C%96/","excerpt":"","text":"将下载好的 main_menu.xml 进行覆盖到C:\\Program Files\\MySQL\\MySQL Workbench 8.0 CE\\data修改mysql的默认语言","categories":[{"name":"汉化","slug":"汉化","permalink":"http://fangpengcheng.com/categories/%E6%B1%89%E5%8C%96/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://fangpengcheng.com/tags/Mysql/"}]},{"title":"oracle创建一个新的数据库","slug":"oracle创建一个新的数据库","date":"2019-11-20T01:47:43.000Z","updated":"2020-06-11T10:10:48.086Z","comments":true,"path":"2019/11/20/oracle创建一个新的数据库/","link":"","permalink":"http://fangpengcheng.com/2019/11/20/oracle%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"图形化页面手动创建启动oracle运行Database Configuration Assistant","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://fangpengcheng.com/tags/Oracle/"}]},{"title":"eclipes反编译软件安装","slug":"eclipes反编译软件安装","date":"2019-11-19T09:23:03.000Z","updated":"2020-06-11T09:45:36.004Z","comments":true,"path":"2019/11/19/eclipes反编译软件安装/","link":"","permalink":"http://fangpengcheng.com/2019/11/19/eclipes%E5%8F%8D%E7%BC%96%E8%AF%91%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/","excerpt":"","text":"在Eclipse插件中搜索Decompiler点击安装即可","categories":[],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://fangpengcheng.com/tags/Eclipse/"}]},{"title":"Java字符串数字转成基本数据类型","slug":"Java字符串数字转成基本数据类型","date":"2019-11-19T02:19:13.000Z","updated":"2019-12-21T04:19:16.790Z","comments":true,"path":"2019/11/19/Java字符串数字转成基本数据类型/","link":"","permalink":"http://fangpengcheng.com/2019/11/19/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E5%AD%97%E8%BD%AC%E6%88%90%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"注意事项long类型只能接受19位数字代码123String a &#x3D; &quot;1234567891112555113&quot;;long parseLong &#x3D; Long.parseLong(a,10);System.out.println(parseLong); 输出结果11234567891112555113 超过19位数字就会报错 代码123String a &#x3D; &quot;12345678911125551130&quot;;long parseLong &#x3D; Long.parseLong(a,10);System.out.println(parseLong); 输出结果1234Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;12345678911125551130&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:592) at test.test004.main(test004.java:6)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"mysql安装","slug":"mysql安装","date":"2019-11-16T14:02:35.000Z","updated":"2020-06-11T10:09:32.640Z","comments":true,"path":"2019/11/16/mysql安装/","link":"","permalink":"http://fangpengcheng.com/2019/11/16/mysql%E5%AE%89%E8%A3%85/","excerpt":"","text":"mysql的安装下载网址https://dev.mysql.com/downloads/mysql/ window下安装mysql下载下来是压缩包，解压到指定目录 修改mysql配置文件在mysql主目录下创建my.ini , 创建一个data文件夹并保证下面没有文件，创建一个Uploads用来存放导出数据 内容(注意目录的不同)1234567891011121314151617181920212223[mysqld]port&#x3D;3306character_set_server&#x3D;utf8basedir&#x3D;E:\\programming\\mysql-5.7.28-winx64datadir&#x3D;E:\\programming\\mysql-5.7.28-winx64\\dataserver-id&#x3D;1sql_mode&#x3D;NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTIONlower_case_table_names&#x3D;1innodb_file_per_table &#x3D; 1log_timestamps&#x3D;SYSTEMlog-error &#x3D; error.logslow_query_log &#x3D; 1slow_query_log_file &#x3D; slow.loglong_query_time &#x3D; 5log-bin &#x3D; binlogbinlog_format &#x3D; rowexpire_logs_days &#x3D; 15log_bin_trust_function_creators &#x3D; 1secure-file-priv&#x3D;E:\\programming\\mysql-5.7.28-winx64\\Uploads[client] default-character-set&#x3D;utf8 启动mysql以管理员（注意）的身份打开cmd命令工具切换到E:\\programming\\mysql-5.7.28-winx64\\bin初始化mysql（这里初始化要保证data文件夹下没有文件不然会失败）1mysqld --initialize --console 注意默认密码 安装1mysqld install 启动mysql1net start mysql 登录mysql如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可： 1mysql -u root -p 按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应: 1Enter password: 不是本机需要输入指定客户端所要登录的 MySQL 主机名 1mysql -h 主机名 -u 用户名 -p","categories":[{"name":"安装","slug":"安装","permalink":"http://fangpengcheng.com/categories/%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://fangpengcheng.com/tags/Mysql/"}]},{"title":"List判断是否为空","slug":"List判断是否为空","date":"2019-11-11T13:28:04.000Z","updated":"2019-12-21T04:21:30.994Z","comments":true,"path":"2019/11/11/List判断是否为空/","link":"","permalink":"http://fangpengcheng.com/2019/11/11/List%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/","excerpt":"","text":"判断list是否为空创建一个list 123456List&lt;Map&lt;String, Object&gt;&gt; list &#x3D; new ArrayList&lt;Map&lt;String,Object&gt;&gt;();Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();map.put(&quot;1&quot;, &quot;1111&quot;);map.put(&quot;2&quot;, &quot;2222&quot;);map.put(&quot;3&quot;, &quot;3333&quot;);list.add(map); 方法1 list.isEmpty() 判断有没有元素12345if (list.isEmpty()) &#123; System.out.println(&quot;list为空&quot;);&#125;else &#123; System.out.println(&quot;list不为空&quot;);&#125; 方法2 list==null12345if (list&#x3D;&#x3D;null) &#123; System.out.println(&quot;list为空&quot;);&#125;else &#123; System.out.println(&quot;list不为空&quot;);&#125; 方法3 list.size() size()返回有几个元素12345if (list.size()&#x3D;&#x3D;0) &#123; System.out.println(&quot;list为空&quot;);&#125;else &#123; System.out.println(&quot;list不为空&quot;);&#125;","categories":[{"name":"List","slug":"List","permalink":"http://fangpengcheng.com/categories/List/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"如何判断Map为空","slug":"如何判断Map为空","date":"2019-11-11T02:54:14.000Z","updated":"2020-06-11T06:23:22.754Z","comments":true,"path":"2019/11/11/如何判断Map为空/","link":"","permalink":"http://fangpengcheng.com/2019/11/11/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADMap%E4%B8%BA%E7%A9%BA/","excerpt":"","text":"判断Map是否为空1234Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();map.put(&quot;1&quot;, &quot;1111&quot;);map.put(&quot;2&quot;, &quot;2222&quot;);map.put(&quot;3&quot;, &quot;3333&quot;); 方法112345 if (map &#x3D;&#x3D; null) &#123; System.out.println(&quot;map为null&quot;); &#125;else &#123; System.out.println(&quot;map不为null&quot;);&#125; 方法212345if (map.isEmpty()) &#123; System.out.println(&quot;map为null&quot;);&#125;else &#123; System.out.println(&quot;map不为null&quot;);&#125; 方法312345if (map.size()&#x3D;&#x3D;0) &#123; System.out.println(&quot;map为null&quot;);&#125;else &#123; System.out.println(&quot;map不为null&quot;);&#125;","categories":[{"name":"Map","slug":"Map","permalink":"http://fangpengcheng.com/categories/Map/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"JavaScript获取当前日期和时间","slug":"JavaScript获取当前日期和时间","date":"2019-11-07T02:45:54.000Z","updated":"2020-06-11T10:07:04.323Z","comments":true,"path":"2019/11/07/JavaScript获取当前日期和时间/","link":"","permalink":"http://fangpengcheng.com/2019/11/07/JavaScript%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/","excerpt":"","text":"JavaScript获取当前日期的方式代码12345678&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;当前时间&quot; onclick&#x3D;&quot;getCurrentDate();&quot;&gt;&lt;script&gt;&#x2F;&#x2F;获取当前日期function getCurrentDate()&#123; var date&#x3D;new Date(); alert(date)&#125;&lt;&#x2F;script&gt; 结果 单独获取年月日时分秒12345678910111213141516function getCurrentDate()&#123; var date&#x3D;new Date(); var year&#x3D;date.getFullYear(); var month&#x3D;date.getMonth()+1; var day&#x3D;date.getDate(); var hours&#x3D;date.getHours(); var minutes&#x3D;date.getMinutes(); var seconds&#x3D;date.getSeconds(); alert(&quot;当前日期时间:&quot;+date); alert(&quot;当前年:&quot;+year); alert(&quot;当前月:&quot;+month); alert(&quot;当前日:&quot;+day); alert(&quot;当前时:&quot;+hours); alert(&quot;当前分:&quot;+minutes); alert(&quot;当前秒:&quot;+seconds);&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"JavaScript中C标签的用法","slug":"JavaScript中C标签的用法","date":"2019-11-06T13:09:19.000Z","updated":"2020-04-22T02:18:13.138Z","comments":true,"path":"2019/11/06/JavaScript中C标签的用法/","link":"","permalink":"http://fangpengcheng.com/2019/11/06/JavaScript%E4%B8%ADC%E6%A0%87%E7%AD%BE%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"C标签1.c标签循环后台返回的list数组2.${item[“user_type”]}中的user_type是后台定义的Key值3.返回值都是字符串 12345&lt;c:forEach items&#x3D;&quot;$&#123;list &#125;&quot; var&#x3D;&quot;item&quot;&gt;var user_type &#x3D; &#39;&lt;c:out value&#x3D;&#39;$&#123;item[&quot;user_type&quot;]&#125;&#39;&gt;&lt;&#x2F;c:out&gt;&#39;var user_id &#x3D; &#39;&lt;c:out value&#x3D;&#39;$&#123;item[&quot;user_id&quot;]&#125;&#39;&gt;&lt;&#x2F;c:out&gt;&#39;var contact &#x3D; &#39;&lt;c:out value&#x3D;&#39;$&#123;item[&quot;contact&quot;]&#125;&#39;&gt;&lt;&#x2F;c:out&gt;&#39;&lt;&#x2F;c:forEach&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"JavaScript中foreach的用法","slug":"JavaScript中foreach的用法","date":"2019-11-06T13:08:46.000Z","updated":"2019-12-21T04:20:53.985Z","comments":true,"path":"2019/11/06/JavaScript中foreach的用法/","link":"","permalink":"http://fangpengcheng.com/2019/11/06/JavaScript%E4%B8%ADforeach%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"数组打印var array = [1,2,3,4,5,6,7]; 一般遍历的方法123456for (var i &#x3D; 0; i &lt; array.length; i++) &#123; document.write(array[i]);&#125; &#96;&#96;&#96; ### for in的方法遍历 for(i in array) { document.write(array[i])} 123### forEach##### 第一种 array.forEach(alert); ##### 第二种","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"String和Object的转换问题","slug":"String和Object的转换问题","date":"2019-11-06T01:15:20.000Z","updated":"2019-12-21T04:25:01.888Z","comments":true,"path":"2019/11/06/String和Object的转换问题/","link":"","permalink":"http://fangpengcheng.com/2019/11/06/String%E5%92%8CObject%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/","excerpt":"","text":"String和Object的转换问题String转Object123String string &#x3D; &quot;aa&quot;;Object object&#x3D; string;System.out.println(object); 输出结果 1aa 例子Object object2 = “aa”; Object转String|方法1:强制类型转换12String string2&#x3D; (String)object2;System.out.println(string2); Object转String|方法2:toString()12String string3 &#x3D; object2.toString();System.out.println(string3); Object转String|方法3:object+””12String string4 &#x3D; object2+&quot;&quot;;System.out.println(string4); Object转String|方法4:String.valueOf()12String string5 &#x3D; String.valueOf(object2);System.out.println(string5); 输出结果 1aa","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"EL表达式","slug":"EL表达式","date":"2019-11-05T09:34:14.000Z","updated":"2020-06-11T09:59:54.389Z","comments":true,"path":"2019/11/05/EL表达式/","link":"","permalink":"http://fangpengcheng.com/2019/11/05/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"学习并运用EL表达式EL表达式是干嘛用的EL表达式语言是一种简单的语言，提供了在JSP中简化表达式的方法，目的是为了尽量减少JSP页面中的Java代码，使得JSP页面的处理程序编写起来更加简洁，便于开发和维护。 EL表达式的简单用法Servlet代码123456789@WebServlet(&quot;&#x2F;FileServlet&quot;)public class FileServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute(&quot;aa&quot;, &quot;张三&quot;); request.setAttribute(&quot;bb&quot;, &quot;李四&quot;); request.setAttribute(&quot;cc&quot;, &quot;王五&quot;); request.getRequestDispatcher(&quot;file.jsp&quot;).forward(request, response); &#125;&#125; JavaScript123&lt;h1&gt;&lt;%&#x3D;request.getAttribute(&quot;aa&quot;)%&gt;&lt;&#x2F;h1&gt;&lt;h1&gt;&lt;%&#x3D;request.getAttribute(&quot;bb&quot;)%&gt;&lt;&#x2F;h1&gt;&lt;h1&gt;&lt;%&#x3D;request.getAttribute(&quot;cc&quot;)%&gt;&lt;&#x2F;h1&gt; 页面显示结果 JavaScript接受方式二123&lt;h1&gt;$&#123;aa&#125;&lt;&#x2F;h1&gt;&lt;h1&gt;$&#123;bb&#125;&lt;&#x2F;h1&gt;&lt;h1&gt;$&#123;cc&#125;&lt;&#x2F;h1&gt; 页面显示结果","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"svn清除url","slug":"svn清除url","date":"2019-11-05T08:54:23.000Z","updated":"2020-06-11T10:11:27.149Z","comments":true,"path":"2019/11/05/svn清除url/","link":"","permalink":"http://fangpengcheng.com/2019/11/05/svn%E6%B8%85%E9%99%A4url/","excerpt":"","text":"清除svn默认的url路径","categories":[],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://fangpengcheng.com/tags/SVN/"}]},{"title":"svn树冲突","slug":"svn树冲突","date":"2019-11-05T08:30:37.000Z","updated":"2019-12-21T04:25:56.992Z","comments":true,"path":"2019/11/05/svn树冲突/","link":"","permalink":"http://fangpengcheng.com/2019/11/05/svn%E6%A0%91%E5%86%B2%E7%AA%81/","excerpt":"","text":"解决svn树冲突问题删除本地（测试过的）将本地文件备份，然后删除本地文件。清除，上传并且右键 TortoiseSVN –&gt; SVN 还原。 本地改名将文件更名然后上传，冲突文件进行删除。","categories":[],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://fangpengcheng.com/tags/SVN/"}]},{"title":"equals的用法","slug":"equals的用法","date":"2019-11-04T14:19:28.000Z","updated":"2020-06-18T03:43:04.858Z","comments":true,"path":"2019/11/04/equals的用法/","link":"","permalink":"http://fangpengcheng.com/2019/11/04/equals%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"==和equals的区别和联系联系“==”是关系运算符，equals是方法，都得到的是布尔返回值。 区别“==”的使用情况1.基本类型，比较值2.引用类型比较地址。3.不能比较没有父子关系的对象 equals的使用情况1.系统类比较内容2.用户自定义类比较地址3.Object类中equals方法 equals的原理","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"VM虚拟机的安装","slug":"VM虚拟机的安装","date":"2019-11-04T12:37:44.000Z","updated":"2020-06-11T10:11:38.535Z","comments":true,"path":"2019/11/04/VM虚拟机的安装/","link":"","permalink":"http://fangpengcheng.com/2019/11/04/VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%89%E8%A3%85/","excerpt":"","text":"安装VM15por虚拟机下载 安装下一步就可以了首先要下载ios系统镜像完成后创建虚拟机将镜像放进去编辑-》首选项-》设备中将打印机勾选","categories":[],"tags":[{"name":"Vmware","slug":"Vmware","permalink":"http://fangpengcheng.com/tags/Vmware/"}]},{"title":"Java读取配置文件内容","slug":"Java读取配置文件内容","date":"2019-11-02T06:37:35.000Z","updated":"2020-06-02T08:37:26.266Z","comments":true,"path":"2019/11/02/Java读取配置文件内容/","link":"","permalink":"http://fangpengcheng.com/2019/11/02/Java%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435&#x2F;** * 获取配置文件 value * * @param key 配置文件的key * @return * @time 2019年11月1日 上午10:50:01 *&#x2F;public static String getCgVal(String key) &#123; BufferedReader br &#x3D; null; InputStreamReader isr &#x3D; null; Properties prop &#x3D; new Properties(); String value &#x3D; &quot;&quot;; try &#123; isr &#x3D; new InputStreamReader(NscUtil.class.getResourceAsStream(&quot;..&#x2F;config.properties&quot;), &quot;UTF-8&quot;); br &#x3D; new BufferedReader(isr); prop.load(br); value &#x3D; (String) prop.get(key); &#125; catch (UnsupportedEncodingException e2) &#123; e2.printStackTrace(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; finally &#123; try &#123; if (isr !&#x3D; null) &#123; isr.close(); &#125; if (br !&#x3D; null) &#123; br.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return value;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java数组的打印方法","slug":"Java数组的打印方法","date":"2019-11-01T07:32:57.000Z","updated":"2019-12-21T04:19:11.722Z","comments":true,"path":"2019/11/01/Java数组的打印方法/","link":"","permalink":"http://fangpengcheng.com/2019/11/01/Java%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%93%E5%8D%B0%E6%96%B9%E6%B3%95/","excerpt":"","text":"Java打印数组的几种方式需要打印的基本类型数组1int[] arr &#x3D; new int[] &#123;5,4,8,0,9,2,1,3,6,7,15,14,12,13,11,10&#125;; 说明：System.out.println(array);这样是不行的，这样打印是的是数组的首地址。 1.传统for循环遍历代码123for (int i &#x3D; 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+&quot; &quot;);&#125; 输出结果15 4 8 0 9 2 1 3 6 7 15 14 12 13 11 10 2.增强for循环打印代码123for (int x : arr) &#123; System.out.print(x+&quot; &quot;);&#125; 输出结果15 4 8 0 9 2 1 3 6 7 15 14 12 13 11 10 3.利用Array类中的toString方法代码1System.out.println(Arrays.toString(arr)); 输出结果1[5, 4, 8, 0, 9, 2, 1, 3, 6, 7, 15, 14, 12, 13, 11, 10] 4.asList方法,将基本数据类型转换成list代码123456List&lt;int[]&gt; asList &#x3D; Arrays.asList(arr);for (int[] is : asList) &#123; for (int is2 : is) &#123; System.out.print(is2+&quot; &quot;); &#125;&#125; 输出结果15 4 8 0 9 2 1 3 6 7 15 14 12 13 11 10 如果是引用数据类型的数组可以直接使用asList方法，将数组转成list集合需要打印的引用类型的数组1String[] array &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;; 1.asList方法，直接打印引用数据类型代码1System.out.println(Arrays.asList(array)); 输出结果1[a, b, c, d, e] 2.Java8新特性打印,方法1代码1Arrays.asList(arrys).stream().forEach(x -&gt; System.out.print(x)); 输出结果1abcde 3.Java8新特性打印,方法2代码1Arrays.asList(array).stream().forEach(System.out::print); 输出结果1abcde","categories":[{"name":"数组","slug":"数组","permalink":"http://fangpengcheng.com/categories/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java排序","slug":"Java排序","date":"2019-11-01T05:34:44.000Z","updated":"2020-06-11T10:05:22.422Z","comments":true,"path":"2019/11/01/Java排序/","link":"","permalink":"http://fangpengcheng.com/2019/11/01/Java%E6%8E%92%E5%BA%8F/","excerpt":"","text":"Java实现排序的几种方法 学习的时候要注意，不稳定的排序法是不重要的。1.冒泡排序基本思想重复走访要进行排序的数列，每次比较两个元素，将较大的数交换之右边，直到没有可以交换的数。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述1.比较相邻的两个元素，如果第一个比第二个数大就进行交换。2.对每一对相邻元素都进行比较，从第一对到最后一对。做完后最后一个数就是最大的数3.重复上述步骤，直到没有任何一个元素需要进行比较 代码123456789101112131415161718192021222324public static void main(String[] args) &#123; int[] arr &#x3D; new int[] &#123;5,4,8,0,9,2,1,3,6,7&#125;; for (int x : arr) &#123; System.out.print(x); &#125; PX(arr);&#125;public static void PX(int[] arr) &#123; int temp; for (int i &#x3D; 0; i &lt; arr.length-1; i++) &#123; for (int j &#x3D; 0; j &lt; arr.length-1; j++) &#123; if (arr[j]&gt;arr[j+1]) &#123; temp &#x3D; arr[j]; arr[j]&#x3D;arr[j+1]; arr[j+1]&#x3D;temp; &#125; &#125; &#125; for (int x : arr) &#123; System.out.print(x); &#125;&#125; 输出结果 1254809213670123456789 2.选择排序基本思想首先定义数组起始位置是最小（大）的,然后与未排序的进行比较大小。将最小（大）的进行交换。再从未进行排序中继续寻找最小（大），将其放置排好的队尾。以此类推，直到排好顺序。 算法描述1.再未排序的队列中找出最小的。2.如果最小元素不是未排序序列的第一个元素，将其与第一个进行交换。3.重复1，2，直至排序结束 代码1234567891011121314151617181920212223public static void main(String[] args) &#123; int[] arr &#x3D; new int[] &#123;5,4,8,0,9,2,1,3,6,7&#125;; for (int x : arr) &#123; System.out.print(x); &#125; XZ(arr);&#125;public static void XZ(int[] arr) &#123; for (int i &#x3D; 0; i &lt; arr.length; i++) &#123; int min &#x3D; i; for (int j &#x3D; i+1; j &lt; arr.length; j++) &#123; if (arr[j]&lt;arr[min]) &#123; min &#x3D; j; &#125; &#125; int temp &#x3D; arr[i]; arr[i] &#x3D; arr[min]; arr[min] &#x3D; temp; &#125; for (int i : arr) &#123; System.out.print(i); &#125;&#125; 输出结果 1254809213670123456789 3.插入排序基本思想通常人们整理扑克牌的方法是一张一张来，将每一张牌插入到其他已经有序的适当位置。在计算机里实现，为了给插入元素提供空间，其余的元素都要往右移一位。 算法描述1.默认第一个是排好的。2.取出下一个元素，在已经排好序的元素末尾开始向前比较3.如果该元素小于末尾元素，则进行交换。4.重复步骤，直到该元素不小于前一个元素。 代码1234567891011121314151617181920212223public static void main(String[] args) &#123; int[] arr &#x3D; new int[] &#123;5,4,8,0,9,2,1,3,6,7&#125;; for (int x : arr) &#123; System.out.print(x); &#125; System.out.println(); CR(arr);&#125;public static void CR(int[] arr) &#123; for (int i &#x3D; 1; i &lt; arr.length; i++) &#123; for (int j &#x3D; i; j &gt; 0; j--) &#123; if (arr[j]&lt;arr[j-1]) &#123; int temp &#x3D; arr[j]; arr[j] &#x3D; arr[j-1]; arr[j-1]&#x3D;temp; &#125; &#125; &#125; for (int i : arr) &#123; System.out.print(i); &#125;&#125; 输出结果1254809213670123456789 4.希尔排序（又叫改进的插入排序,又叫递减增量排序算法）基本思想将待排序的数组按照步长gap进行分组，然后对每组的元素利用直接插入排序的方法进行排序;每次将gap折半减少，循环上次操作；当gap=1时。利用直接插入，完成排序。希尔排序最重要的就是步长。只要步长最后等于1就可以运行，一般去数组长度的一半,然后折半.最后等于1. 代码12345678910111213141516171819202122232425public static void main(String[] args) &#123; int[] arr &#x3D; new int[] &#123;5,4,8,0,9,2,1,3,6,7,15,14,12,13,11,10&#125;; for (int x : arr) &#123; System.out.print(x+&quot; &quot;); &#125; System.out.println(); XR(arr); for (int x : arr) &#123; System.out.print(x+&quot; &quot;); &#125;&#125;private static void XR(int[] arr) &#123; for (int gap &#x3D; 4; gap &gt;0; gap &#x2F;&#x3D; 2) &#123; for (int i &#x3D; gap; i &lt; arr.length; i++) &#123; for (int j &#x3D; i; j &gt; gap-1; j-&#x3D;gap) &#123; if (arr[j]&lt;arr[j-gap]) &#123; int temp &#x3D; arr[j]; arr[j] &#x3D; arr[j-gap]; arr[j-gap] &#x3D; temp; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"排序","slug":"排序","permalink":"http://fangpengcheng.com/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"递归计算n！","slug":"递归计算n！","date":"2019-11-01T03:56:38.000Z","updated":"2020-06-11T09:55:15.600Z","comments":true,"path":"2019/11/01/递归计算n！/","link":"","permalink":"http://fangpengcheng.com/2019/11/01/%E9%80%92%E5%BD%92%E8%AE%A1%E7%AE%97n%EF%BC%81/","excerpt":"","text":"如何使用递归计算n！代码1234567891011public static void main(String[] args) &#123; name(10);&#125;public static void name(int i) &#123; long y &#x3D;1 ; while (i&gt;1) &#123; y&#x3D;i*y; i--; &#125; System.out.println(y);&#125; 结果13628800","categories":[{"name":"递归","slug":"递归","permalink":"http://fangpengcheng.com/categories/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"while和do-while循环的区别","slug":"while和do-while循环的区别","date":"2019-11-01T03:10:49.000Z","updated":"2019-11-06T14:14:39.149Z","comments":true,"path":"2019/11/01/while和do-while循环的区别/","link":"","permalink":"http://fangpengcheng.com/2019/11/01/while%E5%92%8Cdo-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"while和do-while当boolean为false时while先判断后执行，第一次判断为false,循环体一次都不执行do while先执行 后判断，最少执行1次。 123456789boolean r &#x3D; false;while (r) &#123; System.out.println(&quot;while&quot;); break;&#125;do &#123; System.out.println(&quot;do-while&quot;); break;&#125; while (r); 输出结果 1do-while 当boolean 为true时如果while循环第一次判断为true, 则两种循环没有区别。 123456789boolean r &#x3D; true;while (r) &#123; System.out.println(&quot;while&quot;); break;&#125;do &#123; System.out.println(&quot;do-while&quot;); break;&#125; while (r); 输出结果 12whiledo-while","categories":[{"name":"循环","slug":"循环","permalink":"http://fangpengcheng.com/categories/%E5%BE%AA%E7%8E%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"Java的基本数据类型与数据类型的转换规则","slug":"Java的基本数据类型与数据类型的转换规则","date":"2019-10-31T11:08:07.000Z","updated":"2020-06-11T10:04:20.408Z","comments":true,"path":"2019/10/31/Java的基本数据类型与数据类型的转换规则/","link":"","permalink":"http://fangpengcheng.com/2019/10/31/Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99/","excerpt":"","text":"Java的基本数据类型?八大数据类型 转换规则基本类型转换分为自动转换和强制转换 1.自动转换容量小的数据类型可以自动转成容量大的数据类型，低级往高级转，这里的容量值的是表述范围， 1234int i ;byte y&#x3D; 4;i &#x3D; y;System.out.println(i); 输出结果 14 2.强制转换高级往低级转换 1234int i &#x3D; 4;byte y;y &#x3D; (byte) i;System.out.println(y); 输出结果 14","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"逻辑运算符","slug":"逻辑运算符","date":"2019-10-31T10:27:27.000Z","updated":"2020-06-11T09:55:59.666Z","comments":true,"path":"2019/10/31/逻辑运算符/","link":"","permalink":"http://fangpengcheng.com/2019/10/31/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"Java逻辑运算符的用法1.&amp;：逻辑与:and,两个都真则为真,一个假则都假,两个条件都会先求出，再判断当都为真时 12345678int x &#x3D; 3;int y &#x3D; 4;int z &#x3D; 5;if (x&lt;y&amp;y&lt;z) &#123; System.out.println(&quot;真&quot;);&#125;else &#123; System.out.println(&quot;假&quot;); &#125; 输出结果 1真 其中一个为假时 12345678int x &#x3D; 3;int y &#x3D; 4;int z &#x3D; 5;if (x&gt;y&amp;&amp;y&lt;z) &#123; System.out.println(&quot;真&quot;);&#125;else &#123; System.out.println(&quot;假&quot;); &#125; 输出结果 1假 2.&amp;&amp;短路与:先对条件1判断，如果为真，则判断条件2，如果为假，则不判断条件2.效率比逻辑与快一点前一个为假时 12345678int x &#x3D; 3;int y &#x3D; 4;int z &#x3D; 5;if (x&gt;y&amp;&amp;y&lt;z) &#123; System.out.println(&quot;真&quot;);&#125;else &#123; System.out.println(&quot;假&quot;); &#125; 输出结果 1假 3.| 逻辑或:只要一个条件为真，则为真。两个条件都为假是才假12345678int x &#x3D; 3;int y &#x3D; 4;int z &#x3D; 5;if (x&gt;y|y&lt;z) &#123; System.out.println(&quot;真&quot;);&#125;else &#123; System.out.println(&quot;假&quot;); &#125; 输出结果 1真 4.|| 短路或:先判断条件1，条件1为假就判断条件2。如果条件1为真，则不判断条件2，直接返回真12345678int x &#x3D; 3;int y &#x3D; 4;int z &#x3D; 5;if (x&lt;y||y&gt;z) &#123; System.out.println(&quot;真&quot;);&#125;else &#123; System.out.println(&quot;假&quot;); &#125; 输出结果 1真 5.! 逻辑非:条件得反逻辑，如果为真，结果为假，如果为假，结果为真.1234567int x &#x3D; 3;int y &#x3D; 4;if (!(x&lt;y)) &#123; System.out.println(&quot;真&quot;);&#125;else &#123; System.out.println(&quot;假&quot;); &#125; 输出结果 1假 6. ^ 位操作运算符也称为按位异或:2^1，就是2（二进制）的0010，1的（二进制）位0001. 上下相加两个都为0则为0，两个一个为1另一个为0则为11System.out.println(2^2); 输出结果 10 1System.out.println(2^1); 输出结果 13","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"用最有效率的方法算出2乘以8等于多少","slug":"用最有效率的方法算出2乘以8等于多少","date":"2019-10-31T03:59:25.000Z","updated":"2020-06-11T09:56:54.040Z","comments":true,"path":"2019/10/31/用最有效率的方法算出2乘以8等于多少/","link":"","permalink":"http://fangpengcheng.com/2019/10/31/%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91/","excerpt":"","text":"最有效率的2*8使用位运算cpu直接支持的，效率最高 &lt;&lt;:左移左边最高位丢弃，右边补齐0 &gt;&gt;:右移最高位是0，左边补齐0;最高为是1，左边补齐1 123public static void main(String[] args) &#123; System.out.println(2 &lt;&lt; 3); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"i++和++i的区别","slug":"i-和-i的区别","date":"2019-10-31T03:27:27.000Z","updated":"2020-06-11T10:02:35.015Z","comments":true,"path":"2019/10/31/i-和-i的区别/","link":"","permalink":"http://fangpengcheng.com/2019/10/31/i-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"区分i++和++i共同点1.i++和++i都是变量自增1，等价于i=i+1；2.如果++i和i++是单独语句，则两个没有区别 123456&#x2F;&#x2F;测试代码int i &#x3D;1;++i;System.out.println(i);&#x2F;&#x2F;输出结果2 3.i++和++i只针对变量，不能作用于常量,例如5++或者++5 不同点i++ ：先运算后增1 123int x&#x3D;5;int y&#x3D;x++;System.out.println(&quot;x&#x3D;&quot;+x+&quot;, y&#x3D;&quot;+y); 输出结果 1x&#x3D;6, y&#x3D;5 ++x:先增1后运算 123int i&#x3D;5;int y&#x3D;++i;System.out.println(&quot;i&#x3D;&quot;+i+&quot;, y&#x3D;&quot;+y); 输出结果 1i&#x3D;6, y&#x3D;6","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"JavaScript编写九九乘法表","slug":"JavaScript编写九九乘法表","date":"2019-10-31T02:58:28.000Z","updated":"2019-12-21T04:20:28.523Z","comments":true,"path":"2019/10/31/JavaScript编写九九乘法表/","link":"","permalink":"http://fangpengcheng.com/2019/10/31/JavaScript%E7%BC%96%E5%86%99%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/","excerpt":"","text":"九九乘法表代码1234567891011&lt;!-- &#x2F;write() 方法可向文档写入 HTML 表达式或 JavaScript 代码。可列出多个参数(exp1,exp2,exp3,...) ，它们将按顺序被追加到文档中。 --&gt;&lt;script&gt;for (var i &#x3D; 1; i&lt;&#x3D;9; i++) &#123; for (var j &#x3D; 1; j &lt;&#x3D;i; j++) &#123; document.write(&#39;&lt;span&gt;&#39;); document.write(j+&quot;*&quot;+i+&quot;&#x3D;&quot;+j*i+&quot;\\t&quot;); document.write(&#39;&lt;&#x2F;span&gt;&#39;); &#125; document.write(&#39;&lt;br &#x2F;&gt;&#39;);&#125;&lt;&#x2F;script&gt;","categories":[{"name":"九九乘法表","slug":"九九乘法表","permalink":"http://fangpengcheng.com/categories/%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"maven创建log4j","slug":"maven创建log4j","date":"2019-10-31T02:12:48.000Z","updated":"2020-06-11T10:09:23.662Z","comments":true,"path":"2019/10/31/maven创建log4j/","link":"","permalink":"http://fangpengcheng.com/2019/10/31/maven%E5%88%9B%E5%BB%BAlog4j/","excerpt":"","text":"maven如何创建log4j?配置pom.xml文件1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;apache-log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.14&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 创建创建log4j配置文件，默认文件名为：log4j.properties，可以在web.xml进行更改 配置文件内容12345678910111213141516171819202122#所有日志 DEBUG是日志输出优先级，从高到低依次为error，warn，info，debug，低级别的可以输出高级别的日志，如debug可以输出任何优先级的log4j.rootLogger &#x3D; DEBUG,stdout,file#设置包名的输出级别log4j.logger.cn.wdq&#x3D;DEBUG#控制台输出log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target&#x3D;System.outlog4j.appender.stdout.Threshold&#x3D;DEBUGlog4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern&#x3D;%-d&#123;yyyy-MM-dd HH:mm:ss&#125;[ %p ]%m%n#所有文件输出 append是设置追加方式，如果设置成true就会往下追加 false是重新覆盖log4j.appender.file &#x3D; org.apache.log4j.FileAppenderlog4j.appender.file.File &#x3D; D:&#x2F;allDEBUG.loglog4j.appender.file.Encoding&#x3D;UTF-8log4j.appender.file.name &#x3D; fileLogDemolog4j.appender.file.Threshold&#x3D;DEBUGlog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern&#x3D;%-d&#123;yyyy-MM-dd HH:mm:ss&#125;[ %p ]%m%nlog4j.appender.file.append &#x3D; true 测试123456789101112131415&#x2F;&#x2F;引入包名为apache下的import org.apache.log4j.Logger;public class Test &#123; &#x2F;&#x2F;Test.class.getClass()必须与当前类同名 private static Logger log &#x3D; Logger.getLogger(Test.class.getClass()); public static void main(String[] args) &#123; testLog(); &#125; public static void testLog()&#123; log.debug(&quot;debug&quot;);&#x2F;&#x2F;这个是debug专用 log.error(&quot;error&quot;);&#x2F;&#x2F;错误转用 log.info(&quot;info&quot;);&#x2F;&#x2F;输出专用 &#125;&#125;","categories":[{"name":"log4j","slug":"log4j","permalink":"http://fangpengcheng.com/categories/log4j/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://fangpengcheng.com/tags/maven/"}]},{"title":"CAP4表单","slug":"CAP4表单","date":"2019-10-31T01:29:52.000Z","updated":"2020-06-11T09:54:12.832Z","comments":true,"path":"2019/10/31/CAP4表单/","link":"","permalink":"http://fangpengcheng.com/2019/10/31/CAP4%E8%A1%A8%E5%8D%95/","excerpt":"","text":"OA如何新建cap4表单","categories":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/categories/OA/"}],"tags":[]},{"title":"新建一个简单的maven项目","slug":"新建一个简单的maven项目","date":"2019-10-29T10:27:31.000Z","updated":"2020-06-11T09:52:16.558Z","comments":true,"path":"2019/10/29/新建一个简单的maven项目/","link":"","permalink":"http://fangpengcheng.com/2019/10/29/%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84maven%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"如何新建一个maven项目 pom.xml错误 新建完成后的目录结构 增加src/main/webapp的web.xml 注意事项如果是需要部署的项目，则需要打包成war类型，如果只是内部调用或者是作服务使用，则推荐打包成jar类型。","categories":[{"name":"Maven","slug":"Maven","permalink":"http://fangpengcheng.com/categories/Maven/"},{"name":"Java","slug":"Maven/Java","permalink":"http://fangpengcheng.com/categories/Maven/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://fangpengcheng.com/tags/Maven/"}]},{"title":"JavaScript刷新页面的方法","slug":"JavaScript刷新页面的方法","date":"2019-10-29T06:09:51.000Z","updated":"2020-04-22T02:18:32.623Z","comments":true,"path":"2019/10/29/JavaScript刷新页面的方法/","link":"","permalink":"http://fangpengcheng.com/2019/10/29/JavaScript%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"JavaScript如何刷新页面指定去某页123451.history.go(-1) &#x2F;&#x2F;-1后退 2.history.go(1) &#x2F;&#x2F;1前进 3.location.assign(location)&#x2F;&#x2F;当locating内为地址时跳转到该地址4.location&#x3D;location &#x2F;&#x2F;当locating内为地址时跳转到该地址5.location.replace(location)&#x2F;&#x2F;当locating内为地址时跳转到该地址 刷新当前页面1234561.window.location.reload();&#x2F;&#x2F;刷新当前页2.location&#x3D;location &#x2F;&#x2F;location&#x3D;location就表示当前地址3.history.go(0) &#x2F;&#x2F;0表示当前页面刷新4.location.assign(location)&#x2F;&#x2F;location&#x3D;location就表示当前地址5.document.execCommand(&quot;Refresh&quot;)&#x2F;&#x2F;待议6.location.replace(location)&#x2F;&#x2F;location&#x3D;location就表示当前地址 当前地址1document.URL&#x3D;location.href","categories":[{"name":"刷新","slug":"刷新","permalink":"http://fangpengcheng.com/categories/%E5%88%B7%E6%96%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"Java连接Oracle数据库","slug":"Java连接Oracle数据库","date":"2019-10-28T13:36:57.000Z","updated":"2019-12-21T04:18:55.391Z","comments":true,"path":"2019/10/28/Java连接Oracle数据库/","link":"","permalink":"http://fangpengcheng.com/2019/10/28/Java%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"Java如何连接Oracle数据库导入ojdbc5.jar 代码1234567891011121314&#x2F;&#x2F; 1.设置驱动Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&#x2F;&#x2F; 2.获取数据库连接(&quot;jdbc:oracle:thin:@地址:oracle端口号:sid&quot;,&quot;用户名&quot;,&quot;密码&quot;);Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:test&quot;, &quot;system&quot;, &quot;Test123456&quot;);&#x2F;&#x2F; 3.构建SQL语句String sql &#x3D; &quot;insert into STUEND values(123,&#39;abc&#39;)&quot;;&#x2F;&#x2F; 4.执行SQL语句Statement sts &#x3D; conn.createStatement(); &#x2F;&#x2F; 返回的结果是影响的行数int count &#x3D; sts.executeUpdate(sql);System.out.println(&quot;影响的行数：&quot;+count);&#x2F;&#x2F; 5.关闭资源sts.close();conn.close(); 结果1影响的行数：1","categories":[{"name":"数据库连接","slug":"数据库连接","permalink":"http://fangpengcheng.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"},{"name":"Oracle","slug":"Oracle","permalink":"http://fangpengcheng.com/tags/Oracle/"}]},{"title":"Oracle-11g的卸载","slug":"Oracle-11g的卸载","date":"2019-10-28T13:10:04.000Z","updated":"2020-06-11T10:10:24.225Z","comments":true,"path":"2019/10/28/Oracle-11g的卸载/","link":"","permalink":"http://fangpengcheng.com/2019/10/28/Oracle-11g%E7%9A%84%E5%8D%B8%E8%BD%BD/","excerpt":"","text":"Oracle-11g的卸载卸载1.停止服务 2.运行Universal Installer 3.删除注册表位置分别为：1.HKEY_LOCAL_MACHINE\\SOFTWARE2.HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services3.HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application 4.重启电脑，删除Oracle目录5.完成卸载","categories":[{"name":"卸载","slug":"卸载","permalink":"http://fangpengcheng.com/categories/%E5%8D%B8%E8%BD%BD/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://fangpengcheng.com/tags/Oracle/"}]},{"title":"Oracle-11g数据库的安装","slug":"Oracle-11g数据库的安装","date":"2019-10-28T12:57:22.000Z","updated":"2019-12-21T04:32:42.199Z","comments":true,"path":"2019/10/28/Oracle-11g数据库的安装/","link":"","permalink":"http://fangpengcheng.com/2019/10/28/Oracle-11g%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/","excerpt":"","text":"Oracle-11g版本数据库的安装安装1.window10修改安装配置文件 1234567891011&#x2F;&#x2F;OPERATING_SYSTEM RELEASE&#x3D;&quot;6.1&quot;改成OPERATING_SYSTEM RELEASE&#x3D;&quot;6.2&quot;&#x2F;&#x2F;NAME VALUE&#x3D;&quot;Windows 7&quot; 改成NAME VALUE&#x3D;&quot;Windows 10&quot;&#x2F;&#x2F;MAX_LENGTH&#x3D;&quot;1023&quot;改成MAX_LENGTH&#x3D;&quot;2023&quot;&lt;OPERATING_SYSTEM RELEASE&#x3D;&quot;6.2&quot;&gt; &lt;VERSION VALUE&#x3D;&quot;3&quot;&#x2F;&gt; &lt;ARCHITECTURE VALUE&#x3D;&quot;64-bit&quot;&#x2F;&gt; &lt;NAME VALUE&#x3D;&quot;Windows 10&quot;&#x2F;&gt; &lt;ENV_VAR_LIST&gt; &lt;ENV_VAR NAME&#x3D;&quot;PATH&quot; MAX_LENGTH&#x3D;&quot;2023&quot; &#x2F;&gt; &lt;&#x2F;ENV_VAR_LIST&gt;&lt;&#x2F;OPERATING_SYSTEM&gt; 2.打开setup.exe 3.取消更新 4.根据情况选择桌面类或者服务器类 服务器类包含桌面类 5.桌面类的安装 6.服务器类 选择高级安装 7.保存安装完成信息 8.完成安装","categories":[{"name":"安装","slug":"安装","permalink":"http://fangpengcheng.com/categories/%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://fangpengcheng.com/tags/Oracle/"}]},{"title":"Map的遍历","slug":"Map的遍历","date":"2019-10-26T09:53:45.000Z","updated":"2019-12-21T04:21:51.549Z","comments":true,"path":"2019/10/26/Map的遍历/","link":"","permalink":"http://fangpengcheng.com/2019/10/26/Map%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"Map遍历的四种方法定义map12345 Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();map.put(&quot;1&quot;, &quot;张三&quot;);map.put(&quot;2&quot;, &quot;李四&quot;);map.put(&quot;3&quot;, &quot;王五&quot;);map.put(&quot;3&quot;, &quot;路六&quot;); //key重复value就只能取出来一个 第一种通过Map.keySet增强for遍历,普遍使用，二次取值12345&#x2F;&#x2F;map.keySet()就是将key值打散存放到set容器中System.out.println(map.keySet());for (String key : map.keySet()) &#123; System.out.println(map.get(key)+key);&#125; 输出结果1234[1, 2, 3]张三1李四2路六3 第二种通过Map.entrySet使用iterator遍历key和value，迭代器12345678System.out.println(map.keySet());&#x2F;&#x2F;map.entrySet()是取出了[1&#x3D;张三, 2&#x3D;李四, 3&#x3D;路六]这种格式System.out.println(map.entrySet());Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it &#x3D; map.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry &#x3D; it.next(); System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());&#125; 输出结果12345[1, 2, 3][1&#x3D;张三, 2&#x3D;李四, 3&#x3D;路六]key&#x3D; 1 and value&#x3D; 张三key&#x3D; 2 and value&#x3D; 李四key&#x3D; 3 and value&#x3D; 路六 第三种通过Map.entrySet遍历key和value,尤其是容量大时12345System.out.println(map.keySet());System.out.println(map.entrySet());for (Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());&#125; 输出结果12345[1, 2, 3][1&#x3D;张三, 2&#x3D;李四, 3&#x3D;路六]key&#x3D; 1 and value&#x3D; 张三key&#x3D; 2 and value&#x3D; 李四key&#x3D; 3 and value&#x3D; 路六 第四种通过Map.values()遍历所有的value，但不能遍历key123for (String string : map.values()) &#123; System.out.println(string);&#125; ### [1, 2, 3] [1=张三, 2=李四, 3=路六] 张三 李四 路六结论： 每一个被添加的元素都有一个 hashCode(哈希值)，他们先比较哈希值，是否相同？ 不相同的元素，添加进入 HashTable. 如果hashCode相同的话， 再去比较 equals()方法，如果也相同的话，JVM就认为数据已经存在了，就不会添加数据！甚至key相同会覆盖value","categories":[{"name":"Map","slug":"Map","permalink":"http://fangpengcheng.com/categories/Map/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"frame和iframe标签的区别","slug":"frame和iframe标签的区别","date":"2019-10-25T09:44:49.000Z","updated":"2019-12-25T09:16:04.484Z","comments":true,"path":"2019/10/25/frame和iframe标签的区别/","link":"","permalink":"http://fangpengcheng.com/2019/10/25/frame%E5%92%8Ciframe%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"frame和iframe标签的区别1、frame不能脱离frameSet单独使用，iframe可以12345678&lt;frameset cols&#x3D;&quot;25%,*,25%&quot;&gt; &lt;frame src&#x3D;&quot;html4.html&quot;&gt; &lt;frame src&#x3D;&quot;Html4.jsp&quot;&gt;&lt;&#x2F;frameset&gt;&lt;iframe src&#x3D;&quot;&#x2F;&#x2F;www.runoob.com&quot;&gt; &lt;p&gt;您的浏览器不支持 iframe 标签。&lt;&#x2F;p&gt;&lt;&#x2F;iframe&gt; 2、frame不能放在body中,否则不能正常显示,iframe可以和body同时使用1234567891011121314&lt;!--&lt;body&gt;--&gt; &lt;frameset rows&#x3D;&quot;50%,*&quot;&gt; &lt;frame name&#x3D;&quot;frame1&quot; src&#x3D;&quot;test1.htm&quot;&#x2F;&gt; &lt;frame name&#x3D;&quot;frame2&quot; src&#x3D;&quot;test2.htm&quot;&#x2F;&gt;&lt;&#x2F;frameset&gt;&lt;!--&lt;&#x2F;body&gt;--&gt; &lt;body&gt; &lt;frameset&gt; &lt;iframe height&#x3D;&quot;30%&quot;name&#x3D;&quot;frame1&quot; src&#x3D;&quot;test1.htm&quot;&#x2F;&gt; &lt;iframe height&#x3D;&quot;100&quot;name&#x3D;&quot;frame2&quot; src&#x3D;&quot;test2.htm&quot;&#x2F;&gt;&lt;&#x2F;frameset&gt;&lt;&#x2F;body&gt; 3.嵌套在frameSet中的iframe必需放在body中,不嵌套在frameSet中的iframe可以随意使用4.frame的高度只能通过frameSet控制；iframe可以自己控制，不能通过frameSet控制5.iframe 可以放到表格里面。frame 则不行。123456789&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;iframe id&#x3D;&quot;&quot; src&#x3D;&quot;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; 6.iframe是活动帧，而frame是非活动帧 iframe用起来更灵活，不需要frame那么多讲究，而且放的位置也可以自己设。 iframe是内嵌的，比较灵活，不过也有不好的地方，就是位置在不同的浏览器和分辨率下有可能不同，有时会把本来好好的页面搞得变形。 iframe是一个网页中的子框架,两网页间是父子关系， iframe是一个浮动的框架,就是在你的页面里再加上一个页面。 frame用来把页面横着或竖着切开，iframe用来在页面中插入一个矩形的小窗口。 frame是把网页分成多个页面的页面。它要有一个框架集页面frameset。 7.iframe和frame刷新1234&#x2F;&#x2F;frame刷新window.frames[1].某个页面.location.reload();&#x2F;&#x2F;iframe占用了整个页面window.location.reload();","categories":[{"name":"frame和iframe","slug":"frame和iframe","permalink":"http://fangpengcheng.com/categories/frame%E5%92%8Ciframe/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://fangpengcheng.com/tags/Html/"}]},{"title":"判断表单数据为空","slug":"判断表单数据为空","date":"2019-10-25T06:52:40.000Z","updated":"2020-06-11T09:56:25.421Z","comments":true,"path":"2019/10/25/判断表单数据为空/","link":"","permalink":"http://fangpengcheng.com/2019/10/25/%E5%88%A4%E6%96%AD%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E4%B8%BA%E7%A9%BA/","excerpt":"","text":"判断表单数据是否空Html表单1234&lt;form action&#x3D;&quot;##&quot; id&#x3D;&quot;form1&quot; name&#x3D;&quot;form1&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;提交&quot; onclick&#x3D;&quot;name1()&quot;&gt;&lt;&#x2F;form&gt; JavaScript代码123456789101112131415161718&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.10.2&#x2F;jquery.min.js&quot; &#x2F;&gt;&lt;&#x2F;script&gt;&lt;script&gt; function name1()&#123; var name&#x3D;form1.name.value; if(name&#x3D;&#x3D;&quot;&quot;)&#123; alert(&quot;表单数据为空,不能提交&quot;); return; &#125; $.ajax(&#123; url: &#39;FileServlet&#39;, type: &#39;get&#39;, data: $(&#39;#form1&#39;).serialize(), dataType: &#39;text&#39;, success: function (data) &#123; &#125; &#125;); &#125;&lt;&#x2F;script&gt;","categories":[{"name":"表单","slug":"表单","permalink":"http://fangpengcheng.com/categories/%E8%A1%A8%E5%8D%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"},{"name":"Html","slug":"Html","permalink":"http://fangpengcheng.com/tags/Html/"}]},{"title":"HttpServletRequest请求用法和实例","slug":"HttpServletRequest接收参数的几种方法","date":"2019-10-24T08:50:29.000Z","updated":"2020-06-11T10:02:29.525Z","comments":true,"path":"2019/10/24/HttpServletRequest接收参数的几种方法/","link":"","permalink":"http://fangpengcheng.com/2019/10/24/HttpServletRequest%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"Request的用法jsp页面提交代码12345 &lt;form action&#x3D;&quot;FileServlet&quot; method&#x3D;&quot;get&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;id&quot; id&#x3D;&quot;id&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; id&#x3D;&quot;name&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt; &lt;&#x2F;form&gt; request获取请求方式1String method &#x3D; request.getMethod();&#x2F;&#x2F;得到请求的方式为get request获取请求参数value1String parameter &#x3D; request.getParameter(&quot;name&quot;);&#x2F;&#x2F;注：不适用contentType为multipart&#x2F;form-data request获取请求参数key1Enumeration&lt;String&gt; parameterNames &#x3D; request.getParameterNames();&#x2F;&#x2F;获取表单所有的key request获取请求集合123Map&lt;String, String[]&gt; parameterMap &#x3D; request.getParameterMap();&#x2F;&#x2F;返回一个map中是String，String[]String[] strings &#x3D; parameterMap.get(&quot;id&quot;);&#x2F;&#x2F;可以根据map获取里面内容System.out.println(strings[0]); request获取请求地址1StringBuffer requestURL &#x3D; request.getRequestURL(); request获取请求内容1.getParameter()123&#x2F;&#x2F;当编码方式是(application&#x2F;x- www-form-urlencoded)时才能使用.默认编码格式&#x2F;&#x2F;对于传输大块的二进制数这类数据，浏览器采用了另一种编码方式(&quot;multipart&#x2F;form-data&quot;)request.getParameter(&quot;name&quot;); 2.getInputStream()3.getReader()request.getParameter()、 request.getInputStream()、request.getReader()这三种方法是有冲突的，因为流只能被读一次。当编码格式为enctype=multipart/form-data，先使用getParameter不影响后面getInputStream，getReader。request.getInputStream()和request.getReader()在同一个响应中是不能混合使用的,如果混合使用就会抛异常。 12ServletInputStream inputStream &#x3D; request.getInputStream();BufferedReader reader &#x3D; request.getReader();","categories":[{"name":"request","slug":"request","permalink":"http://fangpengcheng.com/categories/request/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"表单提交方式","slug":"表单提交方式","date":"2019-10-24T08:50:29.000Z","updated":"2020-06-11T09:54:57.983Z","comments":true,"path":"2019/10/24/表单提交方式/","link":"","permalink":"http://fangpengcheng.com/2019/10/24/%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/","excerpt":"","text":"form表单提交方式Servlet接受数据12345678@WebServlet(&quot;&#x2F;FileServlet&quot;)public class FileServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String parameter &#x3D; request.getParameter(&quot;name&quot;); System.out.println(parameter); &#125;&#125; 一.submit按钮提交1234&lt;form action&#x3D;&quot;FileServlet&quot; method&#x3D;&quot;get&quot; &gt; &lt;input type&#x3D;&quot;text&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;&lt;&#x2F;form&gt; 二.button按钮提交html代码1234 &lt;form action&#x3D;&quot;FileServlet&quot; method&#x3D;&quot;get&quot; &gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; name&#x3D;&quot;name&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;提交&quot; onclick&#x3D;&quot;name1()&quot;&gt;&lt;&#x2F;form&gt; JavaScript代码12345&lt;script&gt; function name1()&#123; document.getElementById(&quot;nameId&quot;).submit(); &#125;&lt;&#x2F;script&gt; 三.a标签提交1234&lt;form action&#x3D;&quot;FileServlet&quot; id&#x3D;&quot;form1&quot; name&#x3D;&quot;form1&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt; &lt;a onclick&#x3D;&quot; document.getElementById(&#39;form1&#39;).submit() &quot;&gt;提交&lt;&#x2F;a&gt;&lt;&#x2F;form&gt; 四.a标签+ajax提交html代码1234 &lt;form action&#x3D;&quot;#&quot; id&#x3D;&quot;form1&quot; name&#x3D;&quot;form1&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt; &lt;a href&#x3D;&quot;#&quot; id&#x3D;&quot;button&quot; onclick&#x3D;&quot;name1()&quot;&gt;提交&lt;&#x2F;a&gt;&lt;&#x2F;form&gt; JavaScript代码12345678910111213&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.10.2&#x2F;jquery.min.js&quot; &#x2F;&gt;&lt;&#x2F;script&gt;&lt;script&gt;function name1()&#123; $.ajax(&#123; url: &#39;FileServlet&#39;, type: &#39;get&#39;, data: $(&#39;#form1&#39;).serialize(), dataType: &#39;text&#39;, success: function (data) &#123; &#125; &#125;);&#125;&lt;&#x2F;script&gt; 五.ajax提交html代码1234 &lt;form action&#x3D;&quot;##&quot; id&#x3D;&quot;form1&quot;&gt; &#x2F;&#x2F;ajax提交不用添加action和method属性 &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; name&#x3D;&quot;name&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;提交&quot; onclick&#x3D;&quot;name1()&quot;&gt;&lt;&#x2F;form&gt; ajax代码12345678910111213141516 &#x2F;&#x2F;引入了js包 &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.10.2&#x2F;jquery.min.js&quot; &#x2F;&gt;&lt;&#x2F;script&gt; &lt;script&gt; function name1()&#123; $.ajax(&#123; url: &#39;FileServlet&#39;,&#x2F;&#x2F;跳转地址 type: &#39;get&#39;,&#x2F;&#x2F;请求方式 data: $(&#39;#form1&#39;).serialize(),&#x2F;&#x2F;表单数据 dataType: &#39;text&#39;,&#x2F;&#x2F;返回数据类型 async: false,&#x2F;&#x2F;是否异步 success: function (data) &#123; &#125; &#125;); &#125;&lt;&#x2F;script&gt;","categories":[{"name":"表单","slug":"表单","permalink":"http://fangpengcheng.com/categories/%E8%A1%A8%E5%8D%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"},{"name":"Html","slug":"Html","permalink":"http://fangpengcheng.com/tags/Html/"},{"name":"Ajax","slug":"Ajax","permalink":"http://fangpengcheng.com/tags/Ajax/"}]},{"title":"上传文件","slug":"上传文件","date":"2019-10-17T11:12:33.000Z","updated":"2020-06-11T09:56:40.189Z","comments":true,"path":"2019/10/17/上传文件/","link":"","permalink":"http://fangpengcheng.com/2019/10/17/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","excerpt":"","text":"如何上传一个文件?上传文件必须注意事项表单input type=“file” 必须有namerequest接受的时候不能使用request.getParameter();HTML中基于表单的文件上载”的HTTP请求。使用POST方法提交了HTTP请求，并且其内容类型为“ multipart / form-data”，则FileUpload可以解析该请求，并以调用方易于使用的方式提供结果。 Html代码1234&lt;form id&#x3D;&quot;fileId&quot; name&#x3D;&quot;fileName&quot; action&#x3D;&quot;FileServlet&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&#x2F;&gt;&lt;br&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot; &gt;&lt;&#x2F;form&gt;","categories":[{"name":"上传","slug":"上传","permalink":"http://fangpengcheng.com/categories/%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://fangpengcheng.com/tags/Html/"},{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]},{"title":"禁用Html标签","slug":"禁用Html标签","date":"2019-10-14T01:16:33.000Z","updated":"2020-06-11T09:55:49.398Z","comments":true,"path":"2019/10/14/禁用Html标签/","link":"","permalink":"http://fangpengcheng.com/2019/10/14/%E7%A6%81%E7%94%A8Html%E6%A0%87%E7%AD%BE/","excerpt":"","text":"如何禁用Html标签方法一：利用JavaScript 使用id获取。attr()方法设置或返回被选元素的属性值，disabled是禁用属性。当disabled为true时禁用false可以使用 1$(&#39;#file2&#39;).attr(&quot;disabled&quot;,true); 方法二：直接在html代码中添加css样式disabled即可禁用 1&lt;input type&#x3D;&quot;button&quot; name&#x3D;&quot;myButton&quot; value&#x3D;&quot;disable&quot; disabled&gt;","categories":[{"name":"标签设置","slug":"标签设置","permalink":"http://fangpengcheng.com/categories/%E6%A0%87%E7%AD%BE%E8%AE%BE%E7%BD%AE/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"svn上传和删除","slug":"svn上传和删除","date":"2019-10-13T11:11:48.000Z","updated":"2019-12-21T04:25:53.867Z","comments":true,"path":"2019/10/13/svn上传和删除/","link":"","permalink":"http://fangpengcheng.com/2019/10/13/svn%E4%B8%8A%E4%BC%A0%E5%92%8C%E5%88%A0%E9%99%A4/","excerpt":"","text":"SVN是如何上传和删除的首先创建一个空的文件夹（相当于所有项目的仓库），在文件夹右键svn检出，弹出选择版本库地址然后确定，第一次登陆需要输入用户名密码 上传右键桌面选择版本库浏览器然后右键导入文件夹 eclipse上传右键项目 删除右键桌面选择版本库浏览器然后右键删除","categories":[{"name":"上传、删除","slug":"上传、删除","permalink":"http://fangpengcheng.com/categories/%E4%B8%8A%E4%BC%A0%E3%80%81%E5%88%A0%E9%99%A4/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://fangpengcheng.com/tags/SVN/"}]},{"title":"svn清除缓存","slug":"svn清除缓存","date":"2019-10-13T11:06:44.000Z","updated":"2020-06-11T10:11:24.663Z","comments":true,"path":"2019/10/13/svn清除缓存/","link":"","permalink":"http://fangpengcheng.com/2019/10/13/svn%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98/","excerpt":"","text":"问题：如何清理svn的缓存？在设置中找到已保存数据清除日志信息即可，可以解决上传中遇到同名文件夹的问题","categories":[{"name":"清理缓存","slug":"清理缓存","permalink":"http://fangpengcheng.com/categories/%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://fangpengcheng.com/tags/SVN/"}]},{"title":"SVN的下载、安装和汉化","slug":"svn的安装和汉化","date":"2019-10-13T10:29:39.000Z","updated":"2020-06-11T10:11:22.133Z","comments":true,"path":"2019/10/13/svn的安装和汉化/","link":"","permalink":"http://fangpengcheng.com/2019/10/13/svn%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E6%B1%89%E5%8C%96/","excerpt":"","text":"SVN下载官方网站下载：https://www.visualsvn.com/visualsvn/download/tortoisesvn/ Eclipse里安装：搜索svn，点击安装即可 安装教程一路下一步安装地址建议默认 汉化教程下载汉化安装包 https://tortoisesvn.net/downloads.html桌面右键打开svn设置 在常规设置中选择语言进行更改","categories":[{"name":"下载、安装、汉化","slug":"下载、安装、汉化","permalink":"http://fangpengcheng.com/categories/%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E6%B1%89%E5%8C%96/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://fangpengcheng.com/tags/SVN/"}]},{"title":"JavaScript的重载","slug":"JavaScript的重载","date":"2019-10-13T09:40:11.000Z","updated":"2019-12-21T04:20:32.821Z","comments":true,"path":"2019/10/13/JavaScript的重载/","link":"","permalink":"http://fangpengcheng.com/2019/10/13/JavaScript%E7%9A%84%E9%87%8D%E8%BD%BD/","excerpt":"","text":"问题：如何实现JavaScript的重载?在java中可以创建两个方法名称相同，但是参数不同的或参数类型不同的方法，这个模式叫做重载。但是在JavaScript中，使用这种方式定义两个方法，后一个方法会覆盖前一个方法 模拟重载方法一：arguments.length可以获取传入参数的长度 function doAdd(){ if( arguments.length==1){ alert(“1”); }else if( arguments.length==2){ alert(“2”) } }doAdd(1);doAdd(1,2)","categories":[{"name":"重载","slug":"重载","permalink":"http://fangpengcheng.com/categories/%E9%87%8D%E8%BD%BD/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"Html标签的隐藏显示设置","slug":"Html标签的隐藏显示设置","date":"2019-10-12T01:30:34.000Z","updated":"2019-12-25T09:15:57.613Z","comments":true,"path":"2019/10/12/Html标签的隐藏显示设置/","link":"","permalink":"http://fangpengcheng.com/2019/10/12/Html%E6%A0%87%E7%AD%BE%E7%9A%84%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"问题：如何设置Html标签的隐藏和显示?方法一用类class隐藏:1$(&quot;.类名&quot;).hide(); 方法二id隐藏:1$(&quot;#id&quot;).hide(); 方法三style:1style&#x3D;&quot;display:none;&quot; 方法一显示class：1$(&quot;.类名&quot;).show(); 方法二id显示:1$(&quot;#id&quot;).show(); 方法三style:1style&#x3D;&quot;display:block&quot;","categories":[{"name":"标签设置","slug":"标签设置","permalink":"http://fangpengcheng.com/categories/%E6%A0%87%E7%AD%BE%E8%AE%BE%E7%BD%AE/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://fangpengcheng.com/tags/Html/"}]},{"title":"父页面取子页面id以及子页面iframe地址","slug":"父页面取子页面id","date":"2019-10-12T00:58:28.000Z","updated":"2020-06-11T09:55:29.551Z","comments":true,"path":"2019/10/12/父页面取子页面id/","link":"","permalink":"http://fangpengcheng.com/2019/10/12/%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%8F%96%E5%AD%90%E9%A1%B5%E9%9D%A2id/","excerpt":"","text":"问题：如何从父页面取得子页面id？在当前jsp页面地址栏不变的情况下弹出一个jsp页面即iframe内框架取iframe的id? iframe 框架代码父页面取子页面id1parent.document.getElementById(&quot;id&quot;) 取iframe的地址通过父页面取的原因是弹框地址不在当前的jsp页面 1parent.document.getElementById(&quot;id&quot;).contentWindow.location.href","categories":[{"name":"ifream","slug":"ifream","permalink":"http://fangpengcheng.com/categories/ifream/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"js-JSON方法","slug":"js-JSON方法","date":"2019-09-27T15:30:23.000Z","updated":"2020-06-11T10:09:05.213Z","comments":true,"path":"2019/09/27/js-JSON方法/","link":"","permalink":"http://fangpengcheng.com/2019/09/27/js-JSON%E6%96%B9%E6%B3%95/","excerpt":"","text":"Unexpected token o in JSON at position 1 报错原因 JSON.parse()JSON.parse()用于从一个字符串中解析出json对象，如 123456var str &#x3D; &#39;&#123;&quot;name&quot;:&quot;LeonWu&quot;,&quot;age&quot;:&quot;18&quot;&#125;&#39;JSON.parse(str);&#x2F;&#x2F;结果为一个Object&#x2F;&#x2F; age: &quot;18&quot;;&#x2F;&#x2F; name: &quot;LeonWu&quot;; JSON.stringify()JSON.stringify()用于从一个对象解析出字符串，如 1234var a &#x3D; &#123;a:1,b:2,c:&quot;LeonWu&quot;&#125;;JSON.stringify(a);&#x2F;&#x2F;结果为 &quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:&quot;LeonWu&quot;&#125;&quot; 错误原因从java后台传过来的是object类型这里用 &lt;b&gt; JSON.parse() &lt;/b&gt; 会先使用toString()方法变成字符串 字符串为‘object’ 然后在转成json对象，即[Object object]; 解决方法1.如果传过来的是一条数据 直接用JSON.stringify()","categories":[{"name":"json","slug":"json","permalink":"http://fangpengcheng.com/categories/json/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"}]},{"title":"致远OA单点登陆","slug":"致远OA单点登陆","date":"2019-09-22T11:10:25.000Z","updated":"2020-06-11T09:54:24.977Z","comments":true,"path":"2019/09/22/致远OA单点登陆/","link":"","permalink":"http://fangpengcheng.com/2019/09/22/%E8%87%B4%E8%BF%9COA%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/","excerpt":"","text":"需求：地址栏里传进的用户名以及模板编号然后跳转到指定页面 :happy1.修改配置文件ApacheJetspeed\\conf\\SeeyonConfig.cmd 2.加入单点登陆的插件3.@NeedlessCheckLogin 注解是免密登陆，并在controller层下每个方法前面加上4.单点登陆至主页测试账户：http://localhost:8080/seeyon/ext/NscZjzyFpc.do?method=login&amp;userName=ls 1234567891011121314151617@NeedlessCheckLogin public ModelAndView login(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; log.info(\"--------------进入login方法--------------\"); String userName = request.getParameter(\"userName\"); log.info(\"单点登录OA传入用户名\" + userName); User user = AppContext.getCurrentUser(); String url = null; if (user != null) &#123; String loginName = user.getLoginName(); log.info(\"OA当前已登录用户\" + loginName); &#125; else &#123; log.info(\"OA当前没有登录用户\"); &#125; url = \"/seeyon/login/sso?from=gke&amp;ticket=\" + userName; response.sendRedirect(url); return null; &#125; 5.单点登陆至有流程的表单测试账户：http://localhost:8080/seeyon/ext/NscZjzyFpc.do?method=XsxjTemplate&amp;userName=ls&amp;tableCode=XSXJ 数据库查询：1.dao层1public String ssoXsxjTemplate(String tableCode) throws Exception; 123456789101112@Override public String ssoXsxjTemplate(String tableCode) throws Exception &#123; String templateId = \"\"; JDBCAgent jdbc = new JDBCAgent(true); String sql = \" select id from CTP_TEMPLATE where TEMPLETE_NUMBER=?\"; jdbc.execute(sql, tableCode); ResultSet queryResult = jdbc.getQueryResult(); while (queryResult.next()) &#123; templateId = queryResult.getString(1); &#125; return templateId; &#125; 2.controller123456789101112131415161718192021222324252627@NeedlessCheckLogin public ModelAndView XsxjTemplate(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; log.info(\"--------------进入Template方法--------------\"); //获取用户名和模板编号 String userName = request.getParameter(\"userName\"); String tableCode = request.getParameter(\"tableCode\"); String url = \"http://localhost:8080/seeyon/login/sso?from=nscZjzyFpcsso&amp;ticket=\" + userName; log.info(\"userName:\" + userName); log.info(\"tableCode:\" + tableCode); log.info(\"url:\" + url); HttpClientUtil u = new HttpClientUtil(); u.open(url, \"post\"); u.send(); u.close(); String templateId = nsc.ssoXsxjTemplate(tableCode); String url1 = \"collaboration/collaboration.do?method=newColl&amp;templateId=\" + templateId + \"\"; log.info(\"ssoTemplate:\" + templateId); log.info(\"url1:\" + url1); TicketInfo ticketInfo = com.seeyon.ctp.portal.sso.SSOTicketBean.getTicketInfo(userName); if (ticketInfo != null) &#123; String makeURLOfSSOTicket = SSOTicketBean.makeURLOfSSOTicket(userName, url1); log.info(\"userName:\" + userName); log.info(\"makeURLOfSSOTicket:\" + makeURLOfSSOTicket); response.sendRedirect(makeURLOfSSOTicket); &#125; return null; &#125; 6.单点登陆至无流程的表单测试账户:http://localhost:8080/seeyon/ext/NscZjzyFpc.do?method=FpkTemplate&amp;userName=ls&amp;tableCode=FPK 1.dao1public String ssoFpkTemplate(long formId) throws Exception; 123456789101112@Overridepublic String ssoXsxjTemplate(String tableCode) throws Exception &#123; String templateId = \"\"; JDBCAgent jdbc = new JDBCAgent(true); String sql = \" select id from CTP_TEMPLATE where TEMPLETE_NUMBER=?\"; jdbc.execute(sql, tableCode); ResultSet queryResult = jdbc.getQueryResult(); while (queryResult.next()) &#123; templateId = queryResult.getString(1); &#125; return templateId;&#125; 2.controller123456789101112131415161718192021222324252627282930@NeedlessCheckLogin public ModelAndView FpkTemplate(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; log.info(\"--------------进入index方法--------------\"); //获取用户名和模板编号 String userName = request.getParameter(\"userName\"); String tableCode = request.getParameter(\"tableCode\"); String url = \"http://localhost:8080/seeyon/login/sso?from=nscZjzyFpcsso&amp;ticket=\" + userName; log.info(\"userName:\" + userName); log.info(\"url:\" + url); HttpClientUtil u = new HttpClientUtil(); u.open(url, \"post\"); u.send(); u.close(); FormBean formBean = formManager.getFormByFormCode(tableCode); Long formId = formBean.getId(); String formTemplateId = nsc.ssoFpkTemplate(formId); log.info(\"formId:\" + formId); log.info(\"formTemplateId:\" + formTemplateId); String url1 = \"form/formData.do?method=getFormMasterDataList&amp;formId=\" + formId + \"&amp;formTemplateId=\" + formTemplateId + \"\"; log.info(\"url1:\" + url1); TicketInfo ticketInfo = com.seeyon.ctp.portal.sso.SSOTicketBean.getTicketInfo(userName); if (ticketInfo != null) &#123; String makeURLOfSSOTicket = SSOTicketBean.makeURLOfSSOTicket(userName, url1); log.info(\"userName:\" + userName); log.info(\"makeURLOfSSOTicket:\" + makeURLOfSSOTicket); response.sendRedirect(makeURLOfSSOTicket); &#125; return null; &#125;","categories":[{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/categories/OA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"}]}],"categories":[{"name":"List","slug":"List","permalink":"http://fangpengcheng.com/categories/List/"},{"name":"Map","slug":"Map","permalink":"http://fangpengcheng.com/categories/Map/"},{"name":"下拉列表","slug":"下拉列表","permalink":"http://fangpengcheng.com/categories/%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8/"},{"name":"节点事件","slug":"节点事件","permalink":"http://fangpengcheng.com/categories/%E8%8A%82%E7%82%B9%E4%BA%8B%E4%BB%B6/"},{"name":"JDBC","slug":"JDBC","permalink":"http://fangpengcheng.com/categories/JDBC/"},{"name":"汉化","slug":"汉化","permalink":"http://fangpengcheng.com/categories/%E6%B1%89%E5%8C%96/"},{"name":"安装","slug":"安装","permalink":"http://fangpengcheng.com/categories/%E5%AE%89%E8%A3%85/"},{"name":"数组","slug":"数组","permalink":"http://fangpengcheng.com/categories/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://fangpengcheng.com/categories/%E6%8E%92%E5%BA%8F/"},{"name":"递归","slug":"递归","permalink":"http://fangpengcheng.com/categories/%E9%80%92%E5%BD%92/"},{"name":"循环","slug":"循环","permalink":"http://fangpengcheng.com/categories/%E5%BE%AA%E7%8E%AF/"},{"name":"九九乘法表","slug":"九九乘法表","permalink":"http://fangpengcheng.com/categories/%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/"},{"name":"log4j","slug":"log4j","permalink":"http://fangpengcheng.com/categories/log4j/"},{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/categories/OA/"},{"name":"Maven","slug":"Maven","permalink":"http://fangpengcheng.com/categories/Maven/"},{"name":"Java","slug":"Maven/Java","permalink":"http://fangpengcheng.com/categories/Maven/Java/"},{"name":"刷新","slug":"刷新","permalink":"http://fangpengcheng.com/categories/%E5%88%B7%E6%96%B0/"},{"name":"数据库连接","slug":"数据库连接","permalink":"http://fangpengcheng.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"},{"name":"卸载","slug":"卸载","permalink":"http://fangpengcheng.com/categories/%E5%8D%B8%E8%BD%BD/"},{"name":"frame和iframe","slug":"frame和iframe","permalink":"http://fangpengcheng.com/categories/frame%E5%92%8Ciframe/"},{"name":"表单","slug":"表单","permalink":"http://fangpengcheng.com/categories/%E8%A1%A8%E5%8D%95/"},{"name":"request","slug":"request","permalink":"http://fangpengcheng.com/categories/request/"},{"name":"上传","slug":"上传","permalink":"http://fangpengcheng.com/categories/%E4%B8%8A%E4%BC%A0/"},{"name":"标签设置","slug":"标签设置","permalink":"http://fangpengcheng.com/categories/%E6%A0%87%E7%AD%BE%E8%AE%BE%E7%BD%AE/"},{"name":"上传、删除","slug":"上传、删除","permalink":"http://fangpengcheng.com/categories/%E4%B8%8A%E4%BC%A0%E3%80%81%E5%88%A0%E9%99%A4/"},{"name":"清理缓存","slug":"清理缓存","permalink":"http://fangpengcheng.com/categories/%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/"},{"name":"下载、安装、汉化","slug":"下载、安装、汉化","permalink":"http://fangpengcheng.com/categories/%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E6%B1%89%E5%8C%96/"},{"name":"重载","slug":"重载","permalink":"http://fangpengcheng.com/categories/%E9%87%8D%E8%BD%BD/"},{"name":"ifream","slug":"ifream","permalink":"http://fangpengcheng.com/categories/ifream/"},{"name":"json","slug":"json","permalink":"http://fangpengcheng.com/categories/json/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fangpengcheng.com/tags/Java/"},{"name":"OA","slug":"OA","permalink":"http://fangpengcheng.com/tags/OA/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://fangpengcheng.com/tags/Eclipse/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://fangpengcheng.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Hexo","slug":"Hexo","permalink":"http://fangpengcheng.com/tags/Hexo/"},{"name":"Oracle","slug":"Oracle","permalink":"http://fangpengcheng.com/tags/Oracle/"},{"name":"Vmware","slug":"Vmware","permalink":"http://fangpengcheng.com/tags/Vmware/"},{"name":"Linux","slug":"Linux","permalink":"http://fangpengcheng.com/tags/Linux/"},{"name":"chrome","slug":"chrome","permalink":"http://fangpengcheng.com/tags/chrome/"},{"name":"日志","slug":"日志","permalink":"http://fangpengcheng.com/tags/%E6%97%A5%E5%BF%97/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://fangpengcheng.com/tags/Tomcat/"},{"name":"Html","slug":"Html","permalink":"http://fangpengcheng.com/tags/Html/"},{"name":"Maven","slug":"Maven","permalink":"http://fangpengcheng.com/tags/Maven/"},{"name":"SQL","slug":"SQL","permalink":"http://fangpengcheng.com/tags/SQL/"},{"name":"Mysql","slug":"Mysql","permalink":"http://fangpengcheng.com/tags/Mysql/"},{"name":"window","slug":"window","permalink":"http://fangpengcheng.com/tags/window/"},{"name":"HTTP","slug":"HTTP","permalink":"http://fangpengcheng.com/tags/HTTP/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://fangpengcheng.com/tags/JavaScript/"},{"name":"SVN","slug":"SVN","permalink":"http://fangpengcheng.com/tags/SVN/"},{"name":"maven","slug":"maven","permalink":"http://fangpengcheng.com/tags/maven/"},{"name":"Ajax","slug":"Ajax","permalink":"http://fangpengcheng.com/tags/Ajax/"}]}